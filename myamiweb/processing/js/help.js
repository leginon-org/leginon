/**
 * help key : value defined in javascript object notation
 */

var help = {
	'eman' : {
		'imask' : 'Radius of internal mask (in pixels)',
		'nodes' : 'Nodes refers to the number of computer to process on simultaneously. The more nodes you get the faster things will get process, but more nodes requires that you wait longer before being allowed to begin processing.',
		'walltime' : 'Wall time, also called real-world time or wall-clock time, refers to elapsed time as determined by a chronometer such as a wristwatch or wall clock. (The reference to a wall clock is how the term originally got its name.)',
		'cputime' : 'Wall time, also called real-world time or wall-clock time, refers to elapsed time as determined by a chronometer such as a wristwatch or wall clock. (The reference to a wall clock is how the term originally got its name.)',
		'procpernode' : 'Processors per node. Each computer (node) or Garibaldi has 4 processors (procs), so proc/node=4. For some cases, you may want to use less processors on each node, leaving more memory and system resources for each process.',
		'ang' : 'Angular step for projections (in degrees)',
		'itn' : 'Iteration Number',
		'copy' : 'Duplicate the parameters for this iteration',
		'mask' : 'Radius of external mask (in pixels)',
		'imask' : 'Radius of internal mask (in pixels)',
		'amask' : '<b>amask=[r],[threshold],[iter]</b><br />This option applies an automatically generated \'form fitting\' soft mask to the model after each iteration.  The mask generation is generally quite good.  It uses 3 values :<br />First - the smallest radius from the center of the map that contacts some density of the \'good\' part of the map.<br />Second - A threshold density at which all of the undesirable density is disconnected from the desired mass.<br />Third - A number of 1-voxel \'shells\' to include after the correct density has been located (this allows you to use threshold densities higher than the desired isosurface threshold density). The iterative shells will include a \'soft\' Gaussian edge after 2 pixels. ie - if you add 8 shells, the density will decay in this region using a 1/2 width of 3 pixels starting at the 3rd pixel. If the number of shells is specified as a negative value, then the mask will have a sharp edge, and any hollow areas inside the mask will be filled in.',
		'sym' : 'Imposes symmetry on the model, omit this option for no/unknown symmetry<BR/>Examples: c1, c2, d7, etc.',
		'hard' : 'Hard limit for <I>make3d</I> program. This specifies how well the class averages must match the model to be included, 25 is typical',
		'clskeep' : '<b>classkeep=[std dev multiplier]</b><br />This determines how many raw particles are discarded for each class-average. This is defined in terms of the standard-deviation of the self-similarity of the particle set. A value close to 0 (should not be exactly 0) will discard about 50% of the data. 1 is a typical value, and will typically discard 10-20% of the data.',
		'clsiter' : 'Generation of class averages is an iterative process. Rather than just aligning the raw particles to a reference, they are iteratively aligned toeach other to produce a class-average representative of the data, not of the model, eliminating initial model bias. Typically set to 8 in the early rounds and 3 in later rounds - 0 may be used at the end, but model bias may result.',
		'filt3d' : '<b>fil3d=[rad]</b><br />Applies a gaussian low-pass filter to the 3D model between iterations. This can be used to correct problems that may result in high resolution terms being upweighted. [rad] is in pixels, not Angstroms',
		'shrink' : '<b>shrink=[n]</b><br /><i>Experimental</i>, Another option that can produce dramatic speed improvements. In some cases, this option can actually produce an improvement in classification accuracy. This option scales the particles and references down by a factor of [n] before classification. Since data is often heavily oversampled, and classification is dominated by low resolution terms, this can be both safe, and actually improve classification by \'filtering\' out high resolution noise. Generally shrink=2 is safe and effective especially for early refinement. In cases of extreme oversampling, larger values may be ok. This option should NOT be used for the final rounds of refinement at high resolution.',
		'euler2' : '<b>euler2=[oversample factor]</b><br /><i>Experimental</i>, This option should improve convergence and reconstruction quality, but has produced mixed results in the past. It adds an additional step to the refinement process in which class-averages orientations are redetermined by projection-matching. The parameter allows you to decrease the angular step (ang=) used to generateprojections. ie - 2 would produce projections with angular step of ang/2. It may be worth trying, but use it with caution on new projects.',
		'perturb' : '<i>Experimental</i>, potentially useful and at worst should be harmless. Has not been well characterized yet. Rather than generating Euler angles at evenly spaced positions, it adds some randomness to the positions. This should produce a more uniform distribution of data in 3D Fourier space and reduce Fourier artifacts',
		'xfiles' : '<b>xfiles=[mass in kD]</b><br />A convenience option.  For each 3D model it will produce a corresponding x-file (threed.1a.mrc -> x.1.mrc).  Based on the mass, the x-file will be scaled so an isosurface threshold of 1 will contain the specified mass.',
		'tree' : 'This can be a risky option, but it can produce dramatic speedups in the refinement process. Rather than comparing each particle to every reference, this will decimate the reference population to 1/4 (if 2 is specified) or 1/9 (if 3 is specified) of its original size, classify, then locally determine which of the matches is best. Is is safest in conjunction with very small angular steps, ie - large numbers of projections. The safest way to use this is either:<br /><i>a)</i> for high-resolution, small-ang refinement or <br/><i>b)</i> for the initial iterations of refinement (then turn it off for the last couple of iterations).',
		'median' : 'When creating class averages, use the median value for each pixel instead of the average.  Not recommended for larger datasets, as it can result in artifacts.  If your dataset is noisy, and has small particles this is recommended',
		'phscls' : 'This option will use signal to noise ratio weighted phase residual as a classification criteria (instead of the default optimized real space variance). Over the last year or so, people working on cylindrical structures (like GroEL), have noticed that \'side views\' of this particle seem to frequently get classified as being tilted 4 or 5 degrees from the side view. While apparently this didn\'t effect the models significantly at the obtained resolution, it is quite irritating. This problem turns out to be due to resolution mismatch between the 3D model and the individual particles. Using phase residual solves this problem, although it\'s unclear if there is any resolution improvement. This option has a slight speed penalty',
		'fscls' : 'An improvement, albeit an experimental one, over phasecls. phasecls ignores Fourier amplitude when making image comparisons. fscls will use a SNR weighted Fourier shell correlation as a similarity criteria. Preliminary tests have shown that this produces slightly better results than phasecls, but it should still be used with caution.',
		'refine' : 'This will do subpixel alignment of the particle translations for classification and averaging. May have a significant impact at higher resolutions (with a speed penalty).',
		'goodbad' : 'Saves good and bad class averages from 3D reconstruction. Overwrites each new iteration.',
		'eotest' : 'Run the <I>eotest</I> program that performs a 2 way even-odd test to determine the resolution of a reconstruction.',
		'coran' : 'Use correspondence analysis particle clustering algorithm'
	}
}
