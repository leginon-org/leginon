#python
import os
import copy
import math
import numpy
import shutil
import subprocess
#pyami
from pyami import mrc
#appionlib
from appionlib.apCtf import ctfdb
from appionlib import apStack
from appionlib import apDisplay
from appionlib import appiondata
from appionlib import apDefocalPairs
from appionlib import apRecon
from appionlib import apDatabase
from appionlib import apEulerCalc
from appionlib import apParam
from appionlib import starFile

#=====================
def parseFrealignParamFile(paramfile,test=False):
	"""
	parse a typical FREALIGN parameter file from v8.08
	test=True returns two particles for checking its content
	"""
	if not os.path.isfile(paramfile):
		apDisplay.printError("Parameter file does not exist: %s"%(paramfile))

	### cannot assume spaces will separate columns.
	#0000000001111111111222222222233333333334444444444555555555566666666667777777777888888888899999999990000000000
	#1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789
	#     24  219.73   84.00  299.39   15.33  -17.51  10000.     1  27923.7  27923.7  -11.41   0.00    0.00
	f = open(paramfile, "r")
	parttree = []
	apDisplay.printMsg("Processing parameter file: %s"%(paramfile))
	for line in f:
		sline = line.strip()
		if sline[0] == "C":
			### comment line
			continue
		partdict = {
			'partnum': int(line[0:7].strip()),
			# euler1,euler2,euler3 are used by uploadFrealign.py which may be deprecated soon
			'euler1': float(line[8:15]),
			'euler2': float(line[16:23]),
			'euler3': float(line[24:31]),
			# use psi, theta, phi in uploadFrealignRefine.py and in the future
			'psi': float(line[8:15]),
			'theta': float(line[16:23]),
			'phi': float(line[24:31]),
			'shiftx': float(line[32:39]),
			'shifty': float(line[40:47]),
			'mag': int(float(line[47:55])),
			'film': int(line[55:61]),
			'defoc1': float(line[61:70]),
			'defoc2': float(line[70:79]),
			'astang': float(line[79:88]),
		}
		# these are not necessary for Frealign, but are generated by Frealign output
		try: 
			partdict['phase_residual'] = float(line[88:94])
		except ValueError:
			pass
		try:
			partdict['dpres'] = float(line[95:102])
		except ValueError:
			pass

		if len(line)>=109:
			partdict['stackpartnum'] = int(line[103:109].strip())
		parttree.append(partdict)
		# test mode returns only two particles
		if test and len(parttree) == 2:
			break
	f.close()
	if len(parttree) < 2:
		apDisplay.printError("No particles found in parameter file %s"%(paramfile))


	apDisplay.printMsg("Processed %d particles"%(len(parttree)))
	return parttree

#===============
def parseFrealign9ParamFile(paramfile,test=False):
	'''
	parse typical Frealign parameter file from v9 -- returns a dict entry: 
	each key is particle number, value is parameter dictionary
	'''
	if not os.path.isfile(paramfile):
		apDisplay.printError("Parameter file does not exist: %s" % (paramfile))

	f = open(paramfile, "r")
	partdict = {}
	apDisplay.printMsg("Processing parameter file: %s" % (paramfile))
	for line in f:
		sline = line.strip().split()
		if sline[0][0] == "C":
			### comment line
			continue
		paramdict = {
			'partnum' : int(sline[0]),   ### partnum starts with 1, not 0
			'psi' : float(sline[1]),
			'theta' : float(sline[2]),
			'phi' : float(sline[3]),
			'shiftx' : float(sline[4]),
			'shifty' : float(sline[5]),
			'mag' : float(sline[6]),
			'micn' : float(sline[7]),
			'defx' : float(sline[8]),
			'defy' : float(sline[9]),
			'astig' : float(sline[10]),
			}
		try:
			paramdict['occ'] = float(sline[11])
		except:
			paramdict['occ'] = 0.0
		try:
			paramdict['logp'] = float(sline[12])
		except:
			paramdict['logp'] = 0.0
		try:
			paramdict['sigma'] = float(sline[13])
		except:
			paramdict['sigma'] = 1.0
		try:
			paramdict['score'] = float(sline[14])
		except:
			paramdict['score'] = 50.0
		try:
			paramdict['change'] = float(sline[15])
		except:
			paramdict['change'] = 0.0

		partdict[paramdict['partnum']] = paramdict
		# test mode returns only two particles
		if test and len(parttree) == 2:
			break
	f.close()

	if len(partdict) < 2:
		apDisplay.printError("No particles found in parameter file %s" % (paramfile))

	apDisplay.printMsg("Processed %d particles" % (len(partdict)))
	return partdict

def getStackParticlesInOrder(params):
	partorderfile = os.path.join(params['rundir'], 'stackpartorder.list')
	stackid = params['stackid']
	if not os.path.isfile(partorderfile):
		return apStack.getStackParticlesFromId(stackid)
	partfile = open(partorderfile,'r')
	lines = partfile.readlines()
	partorder = map((lambda x:int(x[:-1])),lines)
	partsort = list(partorder)
	partsort.sort()
	if partsort == partorder:
		return apStack.getStackParticlesFromId(stackid)
	apDisplay.printMsg("Preped stack has different order from the original stack.  Getting information by the order of the preped stack")
	stpartdatas = []
	for partnum in partorder:
		stpartdatas.append(apStack.getStackParticle(stackid, partnum))
	return stpartdatas

def convertFrealignSymToAppionSym(frealign_symtext):
	if frealign_symtext[0].lower() == 'i':
		icosdict = {'i':'Icos (2 3 5) Viper/3DEM','i2':'Icos (2 5 3) Crowther'}
		return icosdict[frealign_symtext.lower()]
	elif frealign_symtext[0] == 'O':
		return 'Oct'
	elif frealign_symtext.lower() == 'c1':
		return 'C1'
	else:
		frealign_symtext[0].upper()
		return ''.join(frealign_symtext) + ' (z)'

def initializeParticleParams(iter):
		particleparams = {}
		# frealign requires that the first field to be in consecutive sequence
		particleparams['ptclnum']=iter+1
		particleparams['psi']=0
		particleparams['theta']=0
		particleparams['phi']=0
		particleparams['df1']=0.1 # workaround if no ctf correction
		particleparams['df2']=0.1 # set defocus to 0.1 Angstroms
		particleparams['angast']=0.0
		particleparams['mag'] = 10000 # workaround to get around dstep
		particleparams['shx']=0
		particleparams['shy']=0
		particleparams['film']=1
		particleparams['presa']=0
		particleparams['dpres']=0
		particleparams['pnumber']=iter+1
		particleparams['ampcont']=0.15 #default value for stain. Ice should be .07.		
		return particleparams

#===============
def generateParticleParams(params,modeldata,initparfile='params.0.par',extended=False):
	params['inpar']=os.path.join(params['rundir'],initparfile)
	apDisplay.printMsg("Creating parameter file: "+params['inpar'])
	params['mode']=3
	stackpdata=getStackParticlesInOrder(params)
	first_imageid = stackpdata[0]['particle']['image'].dbid
	# set magnification with first image
	frealign_mag = getFrealignStyleParticleMagnification(stackpdata[0],params['bin'])
	f=open(params['inpar'],'w')
	params['noClassification']=0
	if params['reconiterid']:
		iterdata = apRecon.getRefineIterDataFromIterationId(params['reconiterid'])
		sym_name = modeldata['symmetry']['symmetry']
	
	if (extended):
		print "Writing out extended particle parameters"
	else:
		print "Writing out particle parameters"
		
	if 'last' not in params:
		params['last'] = len(stackpdata)
	for i, particle in enumerate(stackpdata[:params['last']]):
		# defaults
		particleparams = initializeParticleParams(i)
		particleparams['mag'] = frealign_mag
		# for helical reconstructions, film is helix number
		if particle['particle']['helixnum']:
			imgid=particle['particle']['image'].dbid
			helix=particle['particle']['helixnum']
			try:
				if params['lastimgid']!=imgid or params['lasthelix']!=helix:
					params['totalHelix']+=1
			except:
				params['totalHelix']=1
			params['lastimgid']=imgid
			params['lasthelix']=helix
			particleparams['film']=params['totalHelix']
		else:
			particleparams['film']=particle['particle']['image'].dbid - first_imageid + 1
		# extra particle number information not read by Frealign
		particleparams['pnumber']=particle['particleNumber']

		imagedata=particle['particle']['image']
		if params['noctf'] is False:
			if params['defocpair'] is True:
				imagedata = apDefocalPairs.getDefocusPair(imagedata)
			# get tilted parameters first:
			if params['ctftilt'] is True:
				ctfdata = ctfdb.getBestTiltCtfValueForImage(imagedata)
				if ctfdata is None:
					apDisplay.printError("Failed to get ctf parameters")
				# get x,y coordinate of the particle
				nx = particle['particle']['xcoord']
				ny = particle['particle']['ycoord']
				df1,df2 = ctfdb.getParticleTiltDefocus(ctfdata,imagedata,nx,ny)
				# use defocus & astigmatism values
				particleparams['df1']=abs(df1)
				particleparams['df2']=abs(df2)
				particleparams['angast']=ctfdata['angle_astigmatism']
				particleparams['ampcont'] = ctfdata['amplitude_contrast']

			else:
				# first see if there are ctf values
				ctfdata, confidence=ctfdb.getBestCtfValueForImage(imagedata, msg=False,method=params['ctfmethod'])
				## Do we really want value from any method if it is specified?
				if ctfdata is None:
					ctfdata, confidence=ctfdb.getBestCtfValueForImage(imagedata, msg=False)
				if ctfdata is not None:
					# use defocus & astigmatism values
					particleparams['df1']=abs(ctfdata['defocus1']*1e10)
					particleparams['df2']=abs(ctfdata['defocus2']*1e10)
					particleparams['angast']=ctfdata['angle_astigmatism']
					particleparams['ampcont'] = ctfdata['amplitude_contrast']

		# if using parameters from previous reconstruction
		if params['reconiterid'] is not None:
			params['mode']=1
			getStackParticleEulersForIteration(params,particle['particleNumber'])
			fr_eulers = convertAppionEmanEulersToFrealign(params['eman_orient'],sym_name)
			
			particleparams['psi'] = fr_eulers['psi']
			particleparams['theta'] = fr_eulers['theta']
			particleparams['phi'] = fr_eulers['phi']
			particleparams['shx']=-params['eman_orient']['shiftx']
			particleparams['shy']=-params['eman_orient']['shifty']
			if params['eman_orient']['mirror'] is True:
				particleparams['shx']*=-1
		
		if (extended):
			writeParticleParamLineExtended(particleparams,f)
		else:
			writeParticleParamLine(particleparams,f)
	f.close()

#===============
def writeParticleParamLine(particleparams, fileobject):
	p=particleparams
	fileobject.write("%7d%8.2f%8.2f%8.2f%8.2f%8.2f%7.f.%6d%9.1f%9.1f%8.2f%7.2f%8.2f%7d\n" 
		% (p['ptclnum'],p['psi'],p['theta'],p['phi'],p['shx'],p['shy'],p['mag'],
		p['film'],p['df1'],p['df2'],p['angast'],p['presa'],p['dpres'],p['pnumber']))
		
#===============
def writeParticleParamLineExtended(particleparams, fileobject):
	p=particleparams
	fileobject.write("%7d%8.2f%8.2f%8.2f%8.2f%8.2f%7.f.%6d%9.1f%9.1f%8.2f%7.2f%8.2f%7d%9.2f\n" 
		% (p['ptclnum'],p['psi'],p['theta'],p['phi'],p['shx'],p['shy'],p['mag'],
		p['film'],p['df1'],p['df2'],p['angast'],p['presa'],p['dpres'],p['pnumber'],p['ampcont']))

#===============
def readParticleParamLine(line):
	particleparams = {
		'ptclnum': 	int(line[:7]),
		'psi': 		float(line[7:15]),
		'theta': 	float(line[15:23]),
		'phi': 		float(line[23:31]),
		'shx': 		float(line[31:39]),
		'shy':  	float(line[39:47]),
		'mag':  	float(line[47:55]),
		'film': 	int(line[55:61]),
		'df1':  	float(line[61:70]),
		'df2':  	float(line[70:79]),
		'angast': 	float(line[79:87]),
		'presa': 	float(line[87:94]),
		'dpres': 	float(line[94:102]),
		'pnumber': 	int(line[102:109]),
	}
	if len(line) >= 117:
		particleparams['ampcont'] = float(line[109:117])

	import pprint
	pprint.pprint( particleparams )
	return particleparams

#===============
def createFrealignJob (params, jobname, nodenum=None, mode=None, inpar=None, invol=None, first=None, last=None, norecon=False):

	if mode is None:
		mode=params['mode']
	if inpar is None:
		inpar = params['inpar']
	if invol is None:
		invol = params['initmodel']
	if first is None:
		first=params['first']
	if last is None:
		last=params['last']

	# get angular increment for search, if none set a default
	ang = params['ang']
	if ang is None:
		ang=5

	# set relmag to -100 if no 3d reconstruction
	if norecon is True:
		reconrelmag=-100.0
	else:
		reconrelmag=0.0

	f=open(jobname,'w')
	f.write("#!/bin/csh\n")

	# first copy files
	f.write('cd %s\n' % params['rundir'])
	f.write('cd working\n')
	if nodenum is not None:
		workdir = "sub"+str(nodenum)
		f.write('/bin/rm -rf %s\n' %workdir)
		f.write('mkdir %s\n' %workdir)
		f.write('cd %s\n' %workdir)
	f.write('/bin/cp %s workingvol.mrc\n' % invol)
	f.write('\n')
	f.write('frealign << EOF > frealign.out\n')
	f.write('%s,%d,%s,%s,%s,%s,%d,%s,%s,%s,%s,%d\n' 
		% ('M', mode, params['magrefine'], params['defocusrefine'], params['astigrefine'], 
		params['fliptilt'], params['ewald'], params['matches'], params['history'], 
		params['finalsym'], params['fomfilter'], params['fsc']))
	f.write('%d,%d,%.3f,%.2f,%.2f,%d,%d,%d,%d,%d\n' 
		% (params['radius'], params['iradius'], params['apix'], params['ampcontrast'], 
		params['maskthresh'], params['phaseconstant'], params['avgresidual'], ang, 
		params['itmax'], params['maxmatch']))
	f.write('%d %d %d %d %d\n' % (params['psi'], params['theta'], params['phi'], 
		params['deltax'], params['deltay']))
	f.write('%d, %d\n' % (first, last))
	if params['sym']=='Icos':
		f.write('I\n')
	else:
		f.write('%s\n' % (params['sym']))
	f.write('%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f\n' 
		% (params['relmag'], params['apix'], params['targetresidual'], 
		params['residualthresh'], params['cs'], params['kv'], params['beamtiltx'], 
		params['beamtilty']))
	f.write('%.2f,%.2f,%.2f,%.2f\n' 
		% (params['reslimit'], params['hp'], params['lp'], params['bfactor']))
	f.write('%s\n' % (params['stackfile']))
	f.write('match.mrc\n')
	f.write('%s\n' % inpar)
	f.write('params.1.par\n')
	f.write('shift.par\n')
	f.write('%.1f,0.0,0.0,0.0,0.0,0.0,0.0,0.0\n' %reconrelmag)
	f.write('workingvol.mrc\n')
	f.write('weights.mrc\n')
	f.write('odd.mrc\n')
	f.write('even.mrc\n')
	f.write('phasediffs.mrc\n')
	f.write('pointspread.mrc\n')
	f.write('EOF\n')
	f.write('\n')
	f.close()
	os.chmod(jobname,0755)

#===============
def convertAppionEmanEulersToFrealign(eman_eulers, full_sym_name='c1'):
	Eaz = eman_eulers['az']
	Ealt = eman_eulers['alt']
	Ephi = eman_eulers['phi']
	Emirror = eman_eulers['mirror']
	m = apEulerCalc.EulersToRotationMatrixEMAN(Ealt, Eaz, Ephi, Emirror)
	Xphi, Xtheta, Xpsi = apEulerCalc.rotationMatrixToEulersXmipp(m)
	if 'Icos' in full_sym_name:
		# Always covert to 235 orientation
		full_sym_name = 'Icos (2 3 5) Viper/3DEM'
	Xphi, Xtheta, Xpsi = apEulerCalc.convert3DEMEulerFromStandardSym(full_sym_name,Xphi,Xtheta,Xpsi)
	Fphi, Ftheta, Fpsi = apEulerCalc.convertXmippEulersToFrealign(Xphi, Xtheta, Xpsi)
	eulers={"phi":Fphi,"theta":Ftheta,"psi":Fpsi}
	return eulers

def convertEmanEulersToFrealign(eman_eulers, sym='c1'):
	e1 = eman_eulers['az']
	e2 = eman_eulers['alt']
	e3 = eman_eulers['phi']
	m = eman_eulers['mirror']

	# first get Frealign theta
	if m is not True:
		e2+=180
	if e2 < 0:
		e2+=360
	if e2 > 360:
		e2-=360

	# get Frealign phi
	e1-=90
	if e1 < 0:
		e1+=360-(360*int(e1/360.0))
	if e1 > 360:
		e1-=360*int(e1/360.0)

	# get Frealign psi
	if m is True:
		e3+=90
		e3*=-1
	else:
		e3*=-1
		e3+=90
	if e3 < 0:
		e3+=360-(360*int(e3/360.0))
	if e3 > 360:
		e3-=360*int(e3/360.0)

	if sym.lower() == 'icos (5 3 2) eman':
		(e1,e2,e3) = sumEulers([90,-31.7174744,0],[e1,e2,e3])

	eulers={"phi":e1,"theta":e2,"psi":e3}
	return eulers

#===============
def sumEulers(eul1,eul2):
	"""
	combine two successive euler rotations
	NOTE: eulers should be in degrees
	"""
	e11=math.radians(eul1[0])
	e12=math.radians(eul1[1])
	e13=math.radians(eul1[2])
	e21=math.radians(eul2[0])
	e22=math.radians(eul2[1])
	e23=math.radians(eul2[2])

	# convert each set of eulers to a rotation matrix
	r1 = eulersToRotationMatrix(e11,e12,e13)
	r2 = eulersToRotationMatrix(e21,e22,e23)

	m = [[0,0,0],[0,0,0],[0,0,0]]
	for i in range(0,3):
		for j in range (0,3):
			m[i][j] = 0.0
			for k in range (0,3):
				m[i][j] = m[i][j] + (r2[i][k]*r1[k][j])

	# convert near-zeroes and ones
	for j in range (0,3):
		for i in range (0,3):
			if abs(m[i][j]) < 1e-6:
				m[i][j] = 0
			if m[i][j] - 1.0 > -1e-6:
				m[i][j] = 1
			if m[i][j] + 1 < 1e-6:
				m[i][j] = -1

	if m[2][2] == 1:
		theta = 0.0
		psi = 0.0
		if m[0][0] == 0:
			phi = math.degrees(math.asin(m[0][1]))
		else:
			if m[0][0] < 0:
				phi = math.degrees(math.pi+math.atan(m[0][1]/m[0][0]))
			else:
				phi = math.degrees(math.atan(m[0][1]/m[0][0]))
	elif m[2][2] == -1:
		theta = 180.0
		psi = 0.0
		if m[0][0] == 0:
			phi = math.degrees(math.asin(-m[0][1]))
		else:
			if -m[0][0] < 0:
				phi = math.degrees(math.pi+math.atan(-m[0][1]/-m[0][0]))
			else:
				phi = math.degrees(math.atan(-m[0][1]/-m[0][0]))
	else:
		theta = math.degrees(math.acos(m[2][2]))
		sign = cmp(theta,0) # get sign of theta
		if m[2][0] == 0:
			if sign != cmp(m[2][1],0):
				phi = 270.0
			else:
				phi = 90.0
		else:
			if m[2][0] < 0:
				phi = math.degrees(math.pi+math.atan(m[2][1]/m[2][0]))
			else:
				phi = math.degrees(math.atan(m[2][1]/m[2][0]))
		if m[0][2] == 0:
			if sign != cmp(m[1][2],0):
				psi=270.0
			else:
				psi=90.0
		else:
			if -m[0][2] < 0:
				psi = math.degrees(math.pi+math.atan(m[1][2]/-m[0][2]))
			else:
				psi = math.degrees(math.atan(m[1][2]/-m[0][2]))

	if phi < 0:
		phi+=360
	if theta < 0:
		theta+=360
	if psi < 0:
		psi+=360

	return [phi,theta,psi]

def eulersToRotationMatrix(e1,e2,e3):
	"""
	converts 3 eulers to a rotation matrix using
	a zyz convention
	"""
	cphi = math.cos(e1)
	sphi = math.sin(e1)
	ctheta = math.cos(e2)
	stheta = math.sin(e2)
	cpsi = math.cos(e3)
	spsi = math.sin(e3)

	m11 = cphi*ctheta*cpsi-sphi*spsi
	m21 = -cphi*ctheta*spsi-sphi*cpsi
	m31 = cphi*stheta
	m12 = sphi*ctheta*cpsi+cphi*spsi
	m22 = -sphi*ctheta*spsi+cphi*cpsi
	m32 = sphi*stheta
	m13 = -stheta*cpsi
	m23 = stheta*spsi
	m33 = ctheta

	return [[m11,m12,m13],[m21,m22,m23],[m31,m32,m33]]

#===============
def getStackParticleEulersForIteration(params,pnum):
	"""
	find the eulers assigned to a stack particle
	during a refinement.  This function will first
	find the particle id for the given stack particle,
	then find its position in the reference stack, and
	will get the eulers for that particle in the recon
	"""

	# get stack particle id
	stackp = apStack.getStackParticle(params['stackid'],pnum)
	particleid = stackp['particle'].dbid

	# find particle in reference stack
	refstackid = apStack.getStackIdFromIterationId(params['reconiterid'],msg=False)
	refstackp = apStack.getStackParticleFromParticleId(particleid,refstackid, noDie=True)
	if not refstackp:
		apDisplay.printWarning('No classification for stack particle %d in reconstruction iteration id: %d' % (pnum, params['reconiterid']))
		params['noClassification']+=1
		if params['noClassification'] > (float(params['last'])*0.10):
			apDisplay.printError('More than 10% of the particles have no classification, use a different reference reconstruction')
		pclass={}
		pclass['eulers']={}
		pclass['eulers']['euler1']=0.0
		pclass['eulers']['euler2']=0.0
		pclass['inplane_rotation']=0.0
		pclass['mirror']=False
		pclass['shiftx']=0.0
		pclass['shifty']=0.0
	else:
		pclassq = appiondata.ApRefineParticleData()
		pclassq['particle'] = refstackp
		pclassq['refineIter'] = appiondata.ApRefineIterData.direct_query(params['reconiterid'])
		pclass = pclassq.query()
		pclass=pclass[0]

	params['eman_orient']={}
	params['eman_orient']['alt']=pclass['euler1']
	params['eman_orient']['az']=pclass['euler2']
	params['eman_orient']['phi']=pclass['euler3']

	params['eman_orient']['mirror']=pclass['mirror']
	params['eman_orient']['shiftx']=pclass['shiftx']
	params['eman_orient']['shifty']=pclass['shifty']

	return params

#===============
def createMultipleJobs(params):
	"""
	Create multiple job files for frealign reconstruction
	using the mpiexec command
	"""
	# create script that will launch all mpi scripts
	workdir = os.path.join(params['rundir'],"working")
	shutil.rmtree(workdir)
	os.mkdir(workdir)
	cscript = os.path.join(workdir,'frealign_MP.csh')
	params['mp_script']=cscript
	fr = open(cscript,'w')
	#frscript = os.path.join(workdir,'frealign.$PBS_VNODENUM.csh')
	#fr.write("csh "+frscript+"\n")

	# create individual mpi scripts
	ptcls_per_job = params['last']/params['proc']
	r = params['last']%params['proc']
	lastp = 0
	for n in range(params['proc']):
		firstp = lastp+1
		lastp = firstp+ptcls_per_job-1

		if r > 0:
			lastp+=1
			r-=1

		jobname=os.path.join(workdir,"frealign.%d.csh" %n)
		fr.write("-np 1 %s\n" % jobname)
		createFrealignJob(params,jobname,invol=params['itervol'], inpar=params['iterparam'],nodenum=n, first=firstp, last=lastp,norecon=True)
	fr.close()
	os.chmod(cscript,0755)


#===============
def submitMultipleJobs(params):
	"""
	Launch jobs using mpiexec
	Must be launched from within a PBS job!
	"""
	#cmd = 'pbsdsh -v '+params['mp_script']
	cmd = 'mpiexec --app '+params['mp_script']
	print cmd
	proc = subprocess.Popen(cmd, shell=True)
	proc.wait()

#===============
def combineMultipleJobs(params):
	"""
	combine all the parameter files & combine into 1
	then reconstruct the density
	"""
	workdir = os.path.join(params['rundir'],"working")
	paramname = os.path.join(workdir,'params.all.par')
	combine = open(paramname,'w')
	for n in range(params['proc']):
		subdir = "sub"+str(n)
		outpar = os.path.join(workdir,subdir,'params.1.par')
		f=open(outpar,'r')
		lines = f.readlines()
		f.close()
		for n in lines:
			if n[0] != 'C':
				combine.write(n)
	combine.close()
	combinejobname = os.path.join(workdir,'frealign.all.csh')
	createFrealignJob(params,combinejobname,mode=0,invol=params['itervol'],inpar=paramname)
	proc = subprocess.Popen('csh '+combinejobname, shell=True)
	proc.wait()


#===============
def readFrealign9_06ParamLine(dict_value, occdef=100, logpdef=5000, sigmadef=1, scoredef=50.0, changedef=0):
	### code for general usage
	partnum = dict_value['partnum']
	psi = dict_value['psi']
	theta = dict_value['theta']
	phi = dict_value['phi']
	shx = dict_value['shiftx'] 
	shy = dict_value['shifty']
	mag = dict_value['mag']
	micnum = dict_value['micn']
	dx = dict_value['defx']
	dy = dict_value['defy']
	ast = dict_value['astig']
	try:
		occ = dict_value['occ']
	except:
		occ = occdef
	try:
		logp = dict_value['logp']
	except:
		logp = logpdef
	try:
		sigma = p['sigma']
	except:
		sigma = sigmadef
	try:
		score = p['score']
	except:
		score = scoredef
	try:
		change = p['change']
	except:
		change = changedef
	
	d = {
		'i':partnum,'psi':psi,'theta':theta,'phi':phi,'shx':shx,'shy':shy,'mag':mag,'micn':micnum,
		'dx':dx,'dy':dy,'ast':ast,'occ':occ,'logp':logp,'sigma':sigma,'score':score,'change':change
	}
	return d 


#===============
def scale_parfile_frealign8(infile, outfile, mult, newmag=0):
	### outfile
	ff = open(outfile, "w")
	ff.write("%s%8s%8s%8s%8s%8s%8s%6s%9s%9s%8s\n" \
		% ("C      ","psi","theta","phi","shx","shy","mag","film","df1","df2","angast"))

	### read & write params
	params = parseFrealignParamFile(infile)
	k = 1
	olddx = 0
	micnum = 0
	for i,p in enumerate(params):
		if i % 1000 == 0:
			print "finished %d particles from parameter file 1" % i
		partnum = p['partnum']
		psi = p['psi']
		theta = p['theta']
		phi = p['phi']
		shx = p['shiftx'] * mult
		shy = p['shifty'] * mult
		mag = p['mag']
		film = p['film']
		dx = p['defoc1']
		dy = p['defoc2']
		ast = p['astang']
		try:
			pres = p['phase_residual']
		except:
			pass
		
		if olddx != (dx+dy)/2:
			olddx = (dx+dy)/2
			micnum+=1
		if newmag == 0:
			newmag = mag
		ff.write("%7d%8.2f%8.2f%8.2f%8.2f%8.2f%8d%6d%9.1f%9.1f%8.2f\n" \
			% (k, psi, theta, phi, shx, shy, newmag, micnum, dx, dy, ast))
		k+=1
	ff.close()

#=================
def scale_parfile_frealign9_03(infile, outfile, mult, newmag=0):
	''' THIS FUNCTION IS PROBABLY OUTDATED AND MAY ONLY WORK FOR FREALIGN 9.03 '''
	''' note that this may not make sense as it would in frealign8, because frealign9 shifts are in Angstroms '''

	### outfile
	ff = open(outfile, "w")
	ff.write("%s%8s%8s%8s%10s%10s%8s%6s%9s%9s%8s%8s%13s%8s%8s\n" \
		% ("C      ","PSI","THETA","PHI","SHX","SHY","MAG","FILM","DF1","DF2","ANGAST","OCC","-LogP","SCORE","CHANGE"))

	### read & write params
	params = parseFrealign9ParamFile(infile)
	k = 1
	olddx = 0
	micnum = 0

	for i,p in params.iteritems():
		if i % 1000 == 0:
			print "finished %d particles from parameter file 1" % i
		partnum = p['partnum']
		psi = p['psi']
		theta = p['theta']
		phi = p['phi']
		shx = p['shiftx'] * mult
		shy = p['shifty'] * mult
		mag = p['mag']
		film = p['micn']
		dx = p['defx']
		dy = p['defy']
		ast = p['astig']
		occ = p['occ']
		logp = p['logp']
		try:
			score = p['score']
		except:
			score = 50.0
		try:
			change = p['change']
		except:
			change = 0.0
		
		if olddx != (dx+dy)/2:
			olddx = (dx+dy)/2
			micnum += 1
		if newmag == 0:
			newmag = mag
		ff.write("%7d%8.2f%8.2f%8.2f%10.2f%10.2f%8d%6d%9.1f%9.1f%8.2f%8.2f%13d%8.2f%8.2f\n" \
			% (k, psi, theta, phi, shx, shy, newmag, micnum, dx, dy, ast, occ, logp, score, change))
		k+=1
	ff.close()

#=================
def frealign8_to_frealign9(infile, outfile, apix, occ=100, logp=5000, sigma=1, score=50.0, change=0):
	''' modified for version 9.06 and above, character spaces for version <9.06 is different for logp value '''
	### output file
	ff = open(outfile, "w")
	ff.write("%s%8s%8s%8s%10s%10s%8s%6s%9s%9s%8s%8s%10s%11s%8s%8s\n" \
		% ("C      ","PSI","THETA","PHI","SHX","SHY","MAG","FILM","DF1","DF2","ANGAST","OCC","-LogP","SIGMA","SCORE","CHANGE"))
	### read & write params
	params = parseFrealignParamFile(infile)
	for i,p in enumerate(params):
		if i % 1000 == 0:
			print "finished %d particles" % i
		partnum = float(p['partnum'])
		psi = float(p['psi'])
		theta = float(p['theta'])
		phi = float(p['phi'])
		shx = float(p['shiftx'] * apix)
		shy = float(p['shifty'] * apix)
		mag = float(p['mag'])
		film = float(p['film'])
		dx = float(p['defoc1'])
		dy = float(p['defoc2'])
		ast = float(p['astang'])
		ff.write("%7d%8.2f%8.2f%8.2f%10.2f%10.2f%8d%6d%9.1f%9.1f%8.2f%8.2f%10d%11.4f%8.2f%8.2f\n" \
			% (partnum, psi, theta, phi, shx, shy, mag, film, dx, dy, ast, occ, logp, sigma, score, change))
	ff.close()

#=================
def frealign9_to_frealign8(infile, outfile, apix):
	""" pixel size is needed, because frealign9 parameters are in Angstroms, but frealign8 parameters in pixels """	

	### output file
	ff = open(outfile, "w")
	ff.write("%s%8s%8s%8s%8s%8s%8s%6s%9s%9s%8s\n" \
		% ("C      ","PSI","THETA","PHI","SHX","SHY","MAG","FILM","DF1","DF2","ANGAST"))
	### read & write params
	params = parseFrealign9ParamFile(infile)
	for i,p in params.iteritems():
		partnum = p['partnum']
		psi = p['psi']
		theta = p['theta']
		phi = p['phi']
		shx = p['shiftx'] / apix
		shy = p['shifty'] / apix
		mag = p['mag']
		micnum = p['micn']
		dx = p['defx']
		dy = p['defy']
		ast = p['astig']
		ff.write("%7d%8.2f%8.2f%8.2f%8.2f%8.2f%8d%6d%9.1f%9.1f%8.2f\n" \
			% ((i), psi, theta, phi, shx, shy, mag, micnum, dx, dy, ast))	
	ff.close()

#=================
def frealign9_03_to_frealign9_06(infile, outfile):
	''' modified for version 9.06 and above, character spaces for version <9.06 is different for logp value '''
	### output file
	ff = open(outfile, "w")
	ff.write("%s%8s%8s%8s%10s%10s%8s%6s%9s%9s%8s%8s%10s%11s%8s%8s\n" \
		% ("C      ","PSI","THETA","PHI","SHX","SHY","MAG","FILM","DF1","DF2","ANGAST","OCC","-LogP","SIGMA","SCORE","CHANGE"))

	### read & write params
	params = parseFrealign9ParamFile(infile)
	for i,p in params.iteritems():
		partnum = p['partnum']
		psi = p['psi']
		theta = p['theta']
		phi = p['phi']
		shx = p['shiftx'] 
		shy = p['shifty']
		mag = p['mag']
		micnum = p['micn']
		dx = p['defx']
		dy = p['defy']
		ast = p['astig']
		occ = p['occ']
		logp = p['logp']
		try:
			sigma = p['sigma']
		except:
			sigma = 1.0
		try:
			score = p['score']
		except:
			score = 50.0
		try:
			change = p['change']
		except:
			change = 0.0

		ff.write("%7d%8.2f%8.2f%8.2f%10.2f%10.2f%8d%6d%9.1f%9.1f%8.2f%8.2f%10d%11.4f%8.2f%8.2f\n" \
			% (partnum, psi, theta, phi, shx, shy, mag, micnum, dx, dy, ast, occ, logp, sigma, score, change))	
	ff.close()


#===================
def frealign9_06_to_frealign9_03(infile, outfile):
	''' modified for version 9.06 and above, character spaces for version <9.06 is different for logp value '''
	### output file
	ff = open(outfile, "w")
	ff.write("%s%8s%8s%8s%10s%10s%8s%6s%9s%9s%8s%8s%13s%8s%8s\n" \
		% ("C      ","PSI","THETA","PHI","SHX","SHY","MAG","FILM","DF1","DF2","ANGAST","OCC","-LogP","SCORE","CHANGE"))

	### read & write params
	params = parseFrealign9ParamFile(infile)
	for i,p in params.iteritems():
		partnum = p['partnum']
		psi = p['psi']
		theta = p['theta']
		phi = p['phi']
		shx = p['shiftx'] 
		shy = p['shifty']
		mag = p['mag']
		micnum = p['micn']
		dx = p['defx']
		dy = p['defy']
		ast = p['astig']
		occ = p['occ']
		logp = p['logp']
		try:
			sigma = p['sigma']
		except:
			sigma = 0.0
		try:
			score = p['score']
		except:
			score = 0.0
		try:
			change = p['change']
		except:
			change = 0.0

		ff.write("%7d%8.2f%8.2f%8.2f%10.2f%10.2f%8d%6d%9.1f%9.1f%8.2f%8.2f%13d%8.2f%8.2f\n" \
			% (partnum, psi, theta, phi, shx, shy, mag, micnum, dx, dy, ast, occ, sigma, score, change))	
	ff.close()

#=================
def extract_from_paramfile_frealign8(bestparticlefile, inparfile, outparfile):
	'''
		uses EMAN-style list (numbering starts at 0) containing all the particles that should be KEPT. Then takes the input
		frealign8 parameter file, and extracts all of the particles that are in the list to make a new parameter file
	'''
	### read / write files
	bpf = open(bestparticlefile, "r")
	bpflines = bpf.readlines()
	bpfstrip = [int(float(line.strip())) for line in bpflines]
	bpf.close()
	params = parseFrealignParamFile(inparfile)
	ff = open(outparfile, "w")
	ff.write("%s%8s%8s%8s%8s%8s%8s%6s%9s%9s%8s\n" \
	% ("C      ","PSI","THETA","PHI","SHX","SHY","MAG","FILM","DF1","DF2","ANGAST"))

	### read & write params
	olddx = 0
	micnum = 0
	for i, val in enumerate(bpfstrip):
		partnum = params[val]['partnum']
		psi     = params[val]['psi']
		theta   = params[val]['theta']
		phi     = params[val]['phi']
		shx     = params[val]['shiftx']
		shy     = params[val]['shifty']
		mag     = params[val]['mag']
		film    = params[val]['film']
		dx      = params[val]['defoc1']
		dy      = params[val]['defoc2']
		ast     = params[val]['astang']

		if olddx != (dx+dy)/2:
			olddx = (dx+dy)/2
			micnum += 1

		ff.write("%7d%8.2f%8.2f%8.2f%8.2f%8.2f%8d%6d%9.1f%9.1f%8.2f\n" \
			% ((i+1), psi, theta, phi, shx, shy, mag, micnum, dx, dy, ast))
	ff.close()

#=================
def extract_from_paramfile_frealign9(bestparticlefile, inparfile, outparfile, newocc=None):
	'''
		uses EMAN-style list (numbering starts at 0) containing all the particles that should be KEPT. Then takes the input
		frealign9 parameter file, and extracts all of the particles that are in the list to make a new parameter file
	'''
	### read / write files
	bpf = open(bestparticlefile, "r")
	bpflines = bpf.readlines()
	bpfstrip = [int(float(line.strip())) for line in bpflines]
	bpf.close()
	params = parseFrealign9ParamFile(inparfile)
	ff = open(outparfile, "w")
	ff = open(outparfile, "w")
	ff.write("%s%8s%8s%8s%10s%10s%8s%6s%9s%9s%8s%8s%10s%11s%8s%8s\n" \
		% ("C      ","PSI","THETA","PHI","SHX","SHY","MAG","FILM","DF1","DF2","ANGAST","OCC","-LogP","SIGMA","SCORE","CHANGE"))

	### read & write params
	olddx = 0
	micnum = 0

	for i, val in enumerate(bpfstrip):
		partnum = params[val+1]['partnum']
		psi = params[val+1]['psi']
		theta = params[val+1]['theta']
		phi = params[val+1]['phi']
		shx = params[val+1]['shiftx']
		shy = params[val+1]['shifty']
		mag = params[val+1]['mag']
		film = params[val+1]['micn']
		dx = params[val+1]['defx']
		dy = params[val+1]['defy']
		ast = params[val+1]['astig']
		if newocc is not None:
			occ = newocc
		else:
			occ = params[val+1]['occ']
		logp = params[val+1]['logp']
		try:
			sigma = params[val+1]['sigma']
		except:
			sigma = 1.0
		try:
			score = params[val+1]['score']
		except:
			score = 50.0
		try:
			change = params[val+1]['change']
		except:
			change = 0.0

		if olddx != (dx+dy)/2:
			olddx = (dx+dy)/2
			micnum += 1

		ff.write("%7d%8.2f%8.2f%8.2f%10.2f%10.2f%8d%6d%9.1f%9.1f%8.2f%8.2f%10d%11.4f%8.2f%8.2f\n" \
			% (i+1, psi, theta, phi, shx, shy, mag, micnum, dx, dy, ast, occ, logp, sigma, score, change))

	ff.close()

#=================
def exclude_class_from_frealign9_parfile(inparfile, outlist, minocc=50.0, frealign8outfile=None, apix=None, frealign9outfile=None, newocc=None):
	'''
		reads input frealign9 parameter file for a particular class. If the occupancy of the particle is greater than 'minocc', 
		then treats that particle as belonging to the class, and outputs to an EMAN-style list file (starts with 0). Optionally
		can output either a frealign8 or frealign9 style parameter file with that class excluded
	
		modified for version 9.06 and above, character spaces for version <9.06 is different for logp value
	''' 

	if frealign8outfile is not None and apix is None:
		apDisplay.printError("frealign 8 parameter file needs pixel size value to determine proper shift, please specify this option")

	### read & write frealign params
	params = parseFrealign9ParamFile(inparfile)
	partlist = []
	if frealign8outfile is not None:
		ff8 = open(frealign8outfile, "w")
		ff8.write("%s%8s%8s%8s%8s%8s%8s%6s%9s%9s%8s\n" \
			% ("C      ","PSI","THETA","PHI","SHX","SHY","MAG","FILM","DF1","DF2","ANGAST"))
	if frealign9outfile is not None:
		ff9 = open(frealign9outfile, "w")
		ff9.write("%s%8s%8s%8s%10s%10s%8s%6s%9s%9s%8s%8s%10s%11s%8s%8s\n" \
	                % ("C      ","PSI","THETA","PHI","SHX","SHY","MAG","FILM","DF1","DF2","ANGAST","OCC","-LogP","SIGMA","SCORE","CHANGE"))
	k = 1
	olddx = 0
	micnum = 0
	for i,p in params.iteritems():
		partnum = p['partnum']
		psi = p['psi']
		theta = p['theta']
		phi = p['phi']
		shx = p['shiftx']
		shy = p['shifty']
		mag = p['mag']
		film = p['micn']
		dx = p['defx']
		dy = p['defy']
		ast = p['astig']
		occ = p['occ']
		logp = p['logp']
		try:
			sigma = p['sigma']
		except:
			sigma = 1.0
		try:
			score = p['score']
		except:
			score = 50.0
		try:
			change = p['change']
		except:
			change = 0.0

		if olddx != (dx+dy)/2:
			olddx = (dx+dy)/2
			micnum += 1

		### optionally write out new frealign files
		if occ > minocc:
			partlist.append(partnum-1)
			if frealign8outfile is not None:
				f8shx = shx / apix
				f8shy = shy / apix
				ff8.write("%7d%8.2f%8.2f%8.2f%8.2f%8.2f%8d%6d%9.1f%9.1f%8.2f\n" \
					% (k, psi, theta, phi, f8shx, f8shy, mag, micnum, dx, dy, ast))
			if newocc is not None:
				newocc = newocc
			else:
				newocc = occ
			if frealign9outfile is not None:
				ff9.write("%7d%8.2f%8.2f%8.2f%10.2f%10.2f%8d%6d%9.1f%9.1f%8.2f%8.2f%10d%11.4f%8.2f%8.2f\n" \
					% (k, psi, theta, phi, shx, shy, mag, micnum, dx, dy, ast, newocc, logp, sigma, score, change))
			k+=1

	### close frealign files
	if frealign8outfile is not None:
		ff8.close()
	if frealign9outfile is not None:
		ff9.close()

	### write out partlist file
	partlist.sort()
	of = open(outlist, "w")
	for p in partlist:
		of.write("%d\n" % p)
	of.close()
	
def exclude_classes_from_frealign9_parfiles(inparfilebase, outlist, minocc, *classlist):
	'''
	inparfilebase is the base name of the parameter file, w/ iteration number, but w/o class number
	e.g. for parameter file input_20_r1.par, inparfilebase is input_20
	
	classlist refers to a list with class numbers (starting with 1), e.g. [1,4,6]

	outlist is a list containing the particle numbers within the relevant classes (starts with 0)
	'''
	
	if minocc < 50:
		apDisplay.printWarning("minimum occupancy is < 50% ... are you sure you want to include these particles?")	
	
	combined = []
	outbase = apParam.randomString(10)
	for i in classlist:
		parfile = "%s_r%d.par" % (inparfilebase, i)
		exclude_class_from_frealign9_parfile(parfile, "%s_%d.lst" % (outbase,i), minocc=minocc)
		f = open("%s_%d.lst" % (outbase,i), "r")
		lines = f.readlines()
		f.close()
		os.remove("%s_%d.lst" % (outbase,i))
		stripped = [int(l.strip()) for l in lines]
		combined.extend(stripped)
	combined.sort()
	
	### check for duplicates
	last = -1
	for i in reversed(range(0,len(combined))):
		if combined[i] == combined[i-1]:
			tmp = combined.pop(i)
	### write to file
	outlistf = open(outlist, "w")
	for i in combined:
		outlistf.write("%d\n" %i)
	outlistf.close()

def combine_frealign8_parfiles(outparfile, *parfiles):	

	ff = open(outparfile, "w")
	ff.write("%s%8s%8s%8s%8s%8s%8s%6s%9s%9s%8s\n" \
	% ("C      ","PSI","THETA","PHI","SHX","SHY","MAG","FILM","DF1","DF2","ANGAST"))

	total = 0
	micnum = 0
	olddx = 0
	for inparfile in parfiles:
		params = parseFrealignParamFile(inparfile)
		### read & write params
		for i, p in enumerate(params):
			total+=1
			partnum = float(p['partnum'])
			psi = float(p['psi'])
			theta = float(p['theta'])
			phi = float(p['phi'])
			shx = float(p['shiftx'])
			shy = float(p['shifty'])
			mag = float(p['mag'])
			film = float(p['film'])
			dx = float(p['defoc1'])
			dy = float(p['defoc2'])
			ast = float(p['astang'])

			if olddx != (dx+dy)/2:
				olddx = (dx+dy)/2
				micnum += 1
	
			ff.write("%7d%8.2f%8.2f%8.2f%8.2f%8.2f%8d%6d%9.1f%9.1f%8.2f\n" \
				% (total, psi, theta, phi, shx, shy, mag, micnum, dx, dy, ast))
	ff.close()

def combine_frealign9_parfiles(outparfile, *parfiles):	

	ff = open(outparfile, "w")
	ff.write("%s%8s%8s%8s%10s%10s%8s%6s%9s%9s%8s%8s%10s%11s%8s%8s\n" \
		% ("C      ","PSI","THETA","PHI","SHX","SHY","MAG","FILM","DF1","DF2","ANGAST","OCC","-LogP","SIGMA","SCORE","CHANGE"))

	total = 0
	micnum = 0
	olddx = 0
	for inparfile in parfiles:
		params = parseFrealign9ParamFile(inparfile)
		### read & write params
		for i, p in params.iteritems():
			total+=1
			partnum = float(p['partnum'])
			psi = float(p['psi'])
			theta = float(p['theta'])
			phi = float(p['phi'])
			shx = float(p['shiftx'])
			shy = float(p['shifty'])
			mag = float(p['mag'])
			film = float(p['micn'])
			dx = float(p['defx'])
			dy = float(p['defy'])
			ast = float(p['astig'])
			occ = float(p['occ']) 
			logp = float(p['logp'])
			sigma = float(p['sigma'])
			score = float(p['score'])
			change = float(p['change'])

			if olddx != (dx+dy)/2:
				olddx = (dx+dy)/2
				micnum += 1
	
			ff.write("%7d%8.2f%8.2f%8.2f%10.2f%10.2f%8d%6d%9.1f%9.1f%8.2f%8.2f%10d%11.4f%8.2f%8.2f\n" \
				% (total, psi, theta, phi, shx, shy, mag, micnum, dx, dy, ast, occ, logp, sigma, score, change))
	ff.close()

def split_frealign9_parfile(inparfile, *outparfiles):
	''' takes as input a frealign9 parameter file, and splits up the occupancies into however many
	output parameter files one specifies (e.g. 2). Keeps all other input the same '''

	if len(outparfiles) < 1:
		apDisplay.printError("must specify at least one output parameter file")

	### read params
	params = parseFrealign9ParamFile(inparfile)

	for outfile in outparfiles:
		### output file
		ff = open(outfile, "w")
		ff.write("%s%8s%8s%8s%10s%10s%8s%6s%9s%9s%8s%8s%10s%11s%8s%8s\n" \
			% ("C      ","PSI","THETA","PHI","SHX","SHY","MAG","FILM","DF1","DF2","ANGAST","OCC","-LogP","SIGMA","SCORE","CHANGE"))
		### read & write params
		for i,p in params.iteritems():	
			if i % 1000 == 0:
				print "finished %d particles" % i
			partnum = float(p['partnum'])
			psi = float(p['psi'])
			theta = float(p['theta'])
			phi = float(p['phi'])
			shx = float(p['shiftx'])
			shy = float(p['shifty'])
			mag = float(p['mag'])
			film = float(p['micn'])
			dx = float(p['defx'])
			dy = float(p['defy'])
			ast = float(p['astig'])
			occ = float(p['occ']) / len(outparfiles)
			logp = float(p['logp']) 
			sigma = float(p['sigma'])
			score = float(p['score'])
			change = float(p['change'])

			ff.write("%7d%8.2f%8.2f%8.2f%10.2f%10.2f%8d%6d%9.1f%9.1f%8.2f%8.2f%10d%11.4f%8.2f%8.2f\n" \
				% (i, psi, theta, phi, shx, shy, mag, film, dx, dy, ast, occ, logp, sigma, score, change))
		ff.close()

def average_value_frealign9(inparfile, *values):
	### read params
	params = parseFrealign9ParamFile(inparfile)
	for v in values:
		vlist = []
		for i in range(len(params)):
			vlist.append(params[i+1][v])
		print "average %s:" % (v), numpy.average(vlist)


#=================
def replace_CTFs_Frealign9(inparfile, outparfile, ctffile):
	### CTF file with values dx dy astig in three columns

	params = parseFrealign9ParamFile(inparfile)
	f = open(ctffile, "r")
	flines = f.readlines()
	fstrip = [l.strip().split() for l in flines]
	f.close()

	ff = open(outparfile, "w")
	ff.write("%s%8s%8s%8s%10s%10s%8s%6s%9s%9s%8s%8s%10s%11s%8s%8s\n" \
		% ("C      ","PSI","THETA","PHI","SHX","SHY","MAG","FILM","DF1","DF2","ANGAST","OCC","-LogP","SIGMA","SCORE","CHANGE"))

	for i,p in params.iteritems(): # note that i starts with 1 for Frealign params
		# i starts with 0 for numbering
		p['defx']  = float(fstrip[i-1][0])
		p['defy']  = float(fstrip[i-1][1])
		p['astig'] = float(fstrip[i-1][2])
		ff.write("%7d%8.2f%8.2f%8.2f%10.2f%10.2f%8d%6d%9.1f%9.1f%8.2f%8.2f%10d%11.4f%8.2f%8.2f\n" \
			% (p['partnum'], p['psi'], p['theta'], p['phi'], p['shiftx'], p['shifty'], p['mag'], p['micn'], 
			p['defx'], p['defy'], p['astig'], p['occ'], p['logp'], p['sigma'], p['score'], p['change']))
	ff.close()


#==================
def Relion_to_Frealign8(starfile, parfile, mag=None):
	star = starFile.StarFile(starfile)
	star.read()
	dataBlock = star.getDataBlock("data_images")
	loopDict  = dataBlock.getLoopDict()
	
	### write Frealign8 file
	ff = open(parfile, "w")
	ff.write("%s%8s%8s%8s%8s%8s%8s%6s%9s%9s%8s\n" \
		% ("C      ","PSI","THETA","PHI","SHX","SHY","MAG","FILM","DF1","DF2","ANGAST"))

	olddx = 0
	micn = 0
	for i in range(len(loopDict)):
		if i % 1000 == 0:
			print "done with %d particles" % i

		rlnrot = float(loopDict[i]['_rlnAngleRot'])
		rlntilt = float(loopDict[i]['_rlnAngleTilt'])
		rlnpsi = float(loopDict[i]['_rlnAnglePsi'])
		shiftx = float(loopDict[i]['_rlnOriginX']) * -1
		shifty = float(loopDict[i]['_rlnOriginY']) * -1
		dx = float(loopDict[i]['_rlnDefocusU'])
		dy = float(loopDict[i]['_rlnDefocusU'])
		astig = float(loopDict[i]['_rlnDefocusAngle'])

		if mag is None:
			try:
				mag = float(loopDict[i]['_rlnMagnification'])
			except:
				apDisplay.printError("magnification not specified, need to specify magnification")

		phi, theta, psi = apEulerCalc.convertXmippEulersToFrealign(rlnrot, rlntilt, rlnpsi)

		if dx != olddx:
			micn += 1
			olddx = dx

		ff.write("%7d%8.2f%8.2f%8.2f%8.2f%8.2f%8d%6d%9.1f%9.1f%8.2f\n" \
			% (i+1, psi, theta, phi, shiftx, shifty, mag, micn, dx, dy, astig))
	ff.close()

#==================
def Relion_to_Frealign9(starfile, parfile, apix, mag=None, occ=100, logp=5000, sigma=1, score=50.0, change=0):
	star = starFile.StarFile(starfile)
	star.read()
	dataBlock = star.getDataBlock("data_images")
	loopDict  = dataBlock.getLoopDict()
	
	### write Frealign8 file
	ff = open(parfile, "w")
	ff.write("%s%8s%8s%8s%10s%10s%8s%6s%9s%9s%8s%8s%10s%11s%8s%8s\n" \
		% ("C      ","PSI","THETA","PHI","SHX","SHY","MAG","FILM","DF1","DF2","ANGAST","OCC","-LogP","SIGMA","SCORE","CHANGE"))

	olddx = 0
	micn = 0
	for i in range(len(loopDict)):
		if i % 1000 == 0:
			print "done with %d particles" % i

		rlnrot = float(loopDict[i]['_rlnAngleRot'])
		rlntilt = float(loopDict[i]['_rlnAngleTilt'])
		rlnpsi = float(loopDict[i]['_rlnAnglePsi'])
		shiftx = float(loopDict[i]['_rlnOriginX']) * -1
		shifty = float(loopDict[i]['_rlnOriginY']) * -1
		dx = float(loopDict[i]['_rlnDefocusU'])
		dy = float(loopDict[i]['_rlnDefocusU'])
		astig = float(loopDict[i]['_rlnDefocusAngle'])
		if mag is None:
			try:
				mag = float(loopDict[i]['_rlnMagnification'])
			except:
				apDisplay.printError("magnification not specified, need to specify magnification")

		phi, theta, psi = apEulerCalc.convertXmippEulersToFrealign(rlnrot, rlntilt, rlnpsi)
		Fx = shiftx * apix
		Fy = shifty * apix

		if dx != olddx:
			micn += 1
			olddx = dx

		ff.write("%7d%8.2f%8.2f%8.2f%10.2f%10.2f%8d%6d%9.1f%9.1f%8.2f%8.2f%10d%11.4f%8.2f%8.2f\n" \
			% (i+1, psi, theta, phi, Fx, Fy, mag, micn, dx, dy, astig, occ, logp, sigma, score, change))
	ff.close()

#==================
def randomize_Frealign9_parfile_occupancies(parfile, n, logp=5000, sigma=1, score=50.0, change=0):
	'''
		parfile is input parameter file, in frealign9 format, without class number, e.g. RQC_0.par
		n is number of output .par files to generate
	'''

	params = parseFrealign9ParamFile(parfile)
	npart = len(params)

	splitparams = []
	for i in range(n):
		splitparams.append(copy.deepcopy(params))

	for i in range(npart): # note that i starts with 1 for Frealign params
		# i starts with 0 for numbering
		rand_occ_sample = numpy.random.dirichlet((1,)*n)
		for j in range(n):
			splitparams[j][i+1]['occ'] = rand_occ_sample[j]*100

	### write params
	for j in range(n):
		outparfile = "%s_r%d.par" % (parfile[:-4], (j+1))	
		ff = open(outparfile, "w")
		ff.write("%s%8s%8s%8s%10s%10s%8s%6s%9s%9s%8s%8s%10s%11s%8s%8s\n" \
			% ("C      ","PSI","THETA","PHI","SHX","SHY","MAG","FILM","DF1","DF2","ANGAST","OCC","-LogP","SIGMA","SCORE","CHANGE"))
		for i in range(npart):
			ff.write("%7d%8.2f%8.2f%8.2f%10.2f%10.2f%8d%6d%9.1f%9.1f%8.2f%8.2f%10d%11.4f%8.2f%8.2f\n" \
				% (	splitparams[j][i+1]['partnum'], 
					splitparams[j][i+1]['psi'], 
					splitparams[j][i+1]['theta'], 
					splitparams[j][i+1]['phi'], 
					splitparams[j][i+1]['shiftx'], 
					splitparams[j][i+1]['shifty'], 
					splitparams[j][i+1]['mag'], 
					splitparams[j][i+1]['micn'], 
					splitparams[j][i+1]['defx'], 
					splitparams[j][i+1]['defy'], 
					splitparams[j][i+1]['astig'], 
					splitparams[j][i+1]['occ'], 
					splitparams[j][i+1]['logp'], 
					splitparams[j][i+1]['sigma'], 
					splitparams[j][i+1]['score'], 
					splitparams[j][i+1]['change']
				)
			)
		ff.close()

#==================
def combine_best_multimodel_parfiles_into_one(outparfile, *parfiles):

	ff = open(outparfile, "w")
	ff.write("%s%8s%8s%8s%10s%10s%8s%6s%9s%9s%8s%8s%10s%11s%8s%8s\n" \
		% ("C      ","PSI","THETA","PHI","SHX","SHY","MAG","FILM","DF1","DF2","ANGAST","OCC","-LogP","SIGMA","SCORE","CHANGE"))

	allparams = []
	for parfile in parfiles:	
		allparams.append(parseFrealign9ParamFile(parfile))
	npart = len(allparams[0])

	for i in range(npart):
		bestocc = -1
		bestm = -1
		for j in range(len(allparams)):
			occ = allparams[j][i+1]['occ']
			if occ > bestocc:
				bestocc = occ
				bestm = j
		ff.write("%7d%8.2f%8.2f%8.2f%10.2f%10.2f%8d%6d%9.1f%9.1f%8.2f%8.2f%10d%11.4f%8.2f%8.2f\n" \
			% (	
				allparams[bestm][i+1]['partnum'],
				allparams[bestm][i+1]['psi'],
				allparams[bestm][i+1]['theta'],
				allparams[bestm][i+1]['phi'],
				allparams[bestm][i+1]['shiftx'],
				allparams[bestm][i+1]['shifty'],
				allparams[bestm][i+1]['mag'],
				allparams[bestm][i+1]['micn'],
				allparams[bestm][i+1]['defx'],
				allparams[bestm][i+1]['defy'],
				allparams[bestm][i+1]['astig'],
				100,
#				allparams[bestm][i+1]['occ'],
				allparams[bestm][i+1]['logp'],
				allparams[bestm][i+1]['sigma'],
				allparams[bestm][i+1]['score'],
				allparams[bestm][i+1]['change']
			)
		)

	ff.close()
	return

def frealign9_to_spider(inparfile, outspifile):
        ### set params
        params = parseFrealign9ParamFile(inparfile)
	first = 0
	last = len(params)
        of = open(outspifile, "w")
        for i in range(first, last):
                rot = float(params[i+1]['phi'])
                theta = float(params[i+1]['theta'])
                psi = float(params[i+1]['psi'])
                shx = float(params[i+1]['shiftx'])
                shy = float(params[i+1]['shifty'])
                of.write("%10.3f%10.3f%10.3f%10.3f%10.3f\n" % (rot, theta, psi, shx, shy))
        of.close()

def getFrealignStyleParticleMagnification(stackpdata,refinestack_bin):
	stackbin = apStack.getStackBinningFromStackId(stackpdata['stack'].dbid)
	totalbin =  stackbin * refinestack_bin
	imgdata = stackpdata['particle']['image']
	apix = apDatabase.getPixelSize(imgdata) # in angstroms
	camera_pixel = imgdata['camera']['pixel size']['x']*imgdata['camera']['binning']['x'] # in meters
	return camera_pixel / (apix * 1e-10 * totalbin)
