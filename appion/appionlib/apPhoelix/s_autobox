#!/bin/csh -f

# s_autobox: automated version of s_boxer for boxing out and centering helical filaments in preparation for running s_maxi.  filters ctf corrected filament, collapses file, searches for the edges and finds the center of the filament, then uses chopstr to cut out the filament. 
#
# Input: .dft.ctf.f
# Output: .s
# Usage: s_autobox infile xlngth yht2 filval
# Where:
#	infile = list of dft.ctf.f files 
# 	xlngth = length of your boxed out filaments (ex. 322 pixels)
# 	yht2 = y value for the final boxed out image (ex. 128 pixels)
# 	in other words, (xlngth,yht2) = (x,y) for final boxed out image 
#
# LSF 5/19/09, 9/3/09

source phoelix_params

set listfile = $1
set xlngth = $2
set yht2 = $3
set filval = $4
set lines = `wc -l $listfile | awk '{print $1}'`

set i = 1
while ($i <= $lines)
        set filex = `head -$i $listfile | tail -1`
        set filep = `prefix $filex`
	set ncols = `hdim -c < $filex`
	set nrows = `hdim -r < $filex`

rm -f $filep.coord $filep.sort $filep.pk amps.out amps.sort val.out val.sort

## Apply a butterworth filter and collapse the image
cp $filex $filep.temp
s_bg2 $filep.temp $ncols
s_filter $filep.temp $filep.but $filval $step
collapse -r <$filep.but> $filep.col

## Find peaks
# Old way with lpeak that doesn't work on every collapsed file
#lpeak -p 2 < $filep.col > $filep.pks
#cat $filep.pks
#set pka = `cat $filep.pks | awk '{print $1}'`
#set pkb = `cat $filep.pks | awk '{print $2}'`
#echo $pka >> $filep.pk
#echo $pkb >> $filep.pk
#sort -g $filep.pk > $filep.sort
#set pk1 = `head -1 $filep.sort | tail -l | cut -d. -f1`
#set pk2 = `head -2 $filep.sort | tail -1 | cut -d. -f1`
#echo $pk1 $pk2

# New way! Cut collapsed file in half based on the lowest point then find the valley in each half
# In order to find the center ($ymid) the first valley, which is the lowest point ($low), must be found.  Then the areas before (first.out) and after (last.out) the lowest point are extracted and sorted to find the two next lowest points (amp1 and amp2).  The lowest of these (amp1 or amp2) is selected as the second valley.  There must be a buffer region ($buffer) around the first valley so that two adjacent points are not selected as the two valleys. A safe buffer region has been calculated to be 1/5 the diameter of the filament.  If the diameter of the filament is not accurate in master_params, this process could be ineffective at centering and boxing out the filaments.  
vtoxg < $filep.col > $filep.out
awk '{print $2}' $filep.out | sort -g > $filep.sort
set low = `head -1 $filep.sort | tail -1`
set cut = `grep -- $low $filep.out | head -1 | awk '{print $1}' | cut -d. -f1`
set buffer = `ee int[[$diameter : $step] : 5]`
set cutx = `ee $cut + $buffer`
set cut1 = `ee $ncols -$cutx`
tail -$cut1 $filep.out > last.out
set amp1 = `awk '{print $2}' last.out | sort -g | head -1 | tail -1`
set cut2 = `ee $cut - $buffer`
head -$cut2 $filep.out > first.out
set amp2 = `awk '{print $2}' first.out | sort -g | head -1 | tail -1`
echo $amp1 >> amps.out
echo $amp2 >> amps.out
sort -g amps.out > amps.sort
set low2 = `head -1 amps.sort | tail -1`
set val1 = $cut
set val2 = `grep -- $low2 $filep.out | head -1 | awk '{print $1}' | cut -d. -f1`
echo $val1 >> val.out
echo $val2 >> val.out
sort -g val.out > val.sort
set valx = `head -1 val.sort | tail -1`
set valy = `head -2 val.sort | tail -1`
set center = `ee int[[$valx + $valy] : 2]`
echo "Found center of $filex at pixel $center. New boxsize ($xlngth x $yht2)"

## Calculate pad values and box out filament
## Method for vertical filaments. Make sure collapse uses -c above.
#set xmid = `ee [[$valy - $valx] : 2] + $valx | cut -d. -f1`
#set halfwdth = `ee $yht2 : 2`
#set leftpad = `ee $ncols - [$xmid - $halfwdth]`
#set rghtpad = `ee $ncols - [$xmid + $halfwdth]`
#pad -x $leftpad -y $xlngth -lft < $filex > $filep.s1
#pad -x $yht2 -y $xlngth -rgt <$filep.s1> $filep.s

## Calculate three points along filament and box out filament
## Method for horizonal filaments. Make sure collase uses -r above.
set ymid = `ee [[$valy - $valx] : 2] + $valx | cut -d. -f1`
set xmid = `ee $nrows : 2`
set xstrt = `ee $xmid - [$xlngth : 2]`
set xend = `ee [$xlngth : 2] + $xmid`

echo 1 $xstrt $ymid >> $filep.coord
echo 2 $xmid $ymid >> $filep.coord
echo 3 $xend $ymid >> $filep.coord

chopstr -f $filex -d $filep.coord -x0 0 -xl $xlngth -y $yht2 -c $filep -x chop

mv $filep.000.chop $filep.s
s_filter $filep.s $filep.sbut $filval $step
#if ($prehip == 'yes') then
#	echo "Did the filament get centered properly? If not try adjusting filter value (filval)."
#	tkir -f $filep.s
#endif

rm $filep.sort $filep.temp temp.but amps.out amps.sort val.out val.sort first.out last.out

@ i++
end

