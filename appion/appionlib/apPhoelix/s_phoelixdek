#!/bin/csh -f

#####
#
# s_phoelixdek : 
#	Writes a dek file in a format suitable for phoelixdump.
#	Looks in the file $pctffile for zeros in the CTF. Does a bunch
#	of other things. Look in hlx_params for a description of all
#	the parameters. 
#
# Usage (am): s_phoelixdek .mrc .pctf .intercepts .exclusion .llfile.new
# Input files (am): .mrc  .pctf  .intercepts
# Output File (am): .dek
#
# Usage (mt): s_phoelixdek .mrc .pctf .llboint .hlxdump_dek .exclusion
# Input files (mt): .mrc  .pctf  .llboint
# Output File (mt): .dek
#
#####


source phoelix_params
if ($s_verbose) echo `basename $0` $argv

if ($calling_method == am) then
	set file=$1
	#set pctffile=$2
	set predictfile=$2
	set exclusion = $3
	set llfilenew = $4
	set filep = $file:r

	set dekfile=$filep.hlxdump_dek
	set params = `echo $libsx`
	set llfile = "ll"$params[1]"_"$params[2]

	set difile=deltall.dat
else if ($calling_method == mt || $calling_method == tmv || \
	 $calling_method == pfo) then
	set file=$1
	#set pctffile=$2
	set llfile=$2
	set dekfile=$3
	set exclusion = $4
	set filep = $file:r

else
	echo "\$calling_method value ($calling_method) invalid."
	exit
endif

set numlls = `wc -l $llfile | awk '{print $1}'`
set line2=`echo $rmin $rmax $idump $merid $width $iphase`
set spacing=`echo $nl1 $nl2 $nr1 $nr2`

if ( -f $dekfile ) rm $dekfile
touch $dekfile

if ($calling_method == am) then
	rm -f $difile
	rm -f $llfilenew
	touch $difile
endif

## Commenting this out because we do not use phoelix for ctf correction anymore
## If you want to turn it back on, change input files above so pctffile is $2, predictfile is $3, etc. LSF 4/4/11
#set pctfl = `more $pctffile | wc -l`
#if ( -f $pctffile && $pctfl != 0) then
#	set flipnum=`wc -l $pctffile | awk  '{print $1}'`
##	set flipnum=`ee $flipnum - 1`
#	set res_lim=`cat $pctffile | awk '{print $7}'`
#else
#	set exclusion=0
#	set flipnum=0
#	set res_lim=0
#endif

set exclusion=0
set flipnum=0
set res_lim=0

echo $filep >> $dekfile
echo $numlls $step $xshift $yshift $delbr $rotation $shear $tilt >> $dekfile
echo $line2 >> $dekfile
echo $exclusion $flipnum >> $dekfile
echo $res_lim >> $dekfile

echo "0 0 0" >> $dekfile
echo $spacing >> $dekfile

# We need noglob set to handle the = in the 'set parm' line.  See s_peaksrch
# for more info.
if ($?noglob == 0) then
   set noglob_set = 0
   set noglob
else
   set noglob_set = 1
endif

# get ll#'s and bessel orders from llfiles
set i=2
while ( $i <= $numlls )
	set ll=`head -$i $llfile | tail -1 | awk '{print $1}'` 
	set bo=`head -$i $llfile | tail -1 | awk '{print $2}'` 
	set strong=`head -$i $llfile | tail -1 | awk '{printf "%0.4f\n", $3}'`
	if ($calling_method == mt || $calling_method == tmv || \
	    $calling_method == pfo) then 
	    echo $ll $bo $strong >> $dekfile 
	else 
	   set calc=`head -$i $predictfile | tail -1 | awk '{print $2}'`
	   set parm=`grab info.dat $filep =$regno`
	    switch ( $strong )
		case "+":
		    switch ( $parm )
			case -1:
				echo "	J(" $bo ") intercept not found, predicting" >> $filep.log
				echo $ll $bo $calc >> $dekfile 
				breaksw
			default:
				set diffflag=0
				set diff=`ee $parm - $calc | awk '{printf "%f",$1}'`
				echo $ll $diff >> $difile
				if ($s_log) echo "	J(" $bo ") intercept was" $diff "pixels from predicted position" >> $filep.log
				if ($s_log) echo "	J(" $bo ") intercept was" $diff "pixels from predicted position" 
				if (`ee "int[abs[$diff] + 0.5]"` < 1) then
					echo $ll $bo "+" >> $llfilenew
				else 
					echo $ll $bo >> $llfilenew
				endif
				echo $ll $bo $parm >> $dekfile
				breaksw
	   	    endsw
		    @ regno++
		breaksw
		default:
			echo $ll $bo >> $llfilenew
			echo $ll $bo $calc >> $dekfile
		breaksw
	    endsw
	endif
	echo $spacing >> $dekfile
	@ i++
end

if ($noglob_set == 0) then
   unset noglob
endif



