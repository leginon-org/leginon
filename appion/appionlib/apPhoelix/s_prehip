#!/bin/csh -f
#
# Input: .mrc
# Output: .s 
#
# Usage: s_prehip listfile
#
# listfile is a list of all boxed out, horizontal filaments from the dataset. Preferred filename is micrograph_filament#.  
# A letter must precede the micrograph name if it is a number.  
# ex: if micrograph 4397 has 3 filaments they would be named a4397_01.mrc, a4397_02.mrc, and a4397_03.mrc
#
# Make sure that master_params and phoelix_params have been modified for your dataset.  
# Things to check are step, ctf, batch, xlngth, yht, padval, yht2, and frowsize.
#
# Also make sure you have llbo.sa, range.sa, strong.sa, template, cutfit1.dek, cutfit2.dek, cutfit3.dek, chop1.dek, and chop2.dek files.
# Template must have the same number of layer lines and same bessel orders as in llbo.sa. Use your best average or near/far file thus far. 
# cutfit.dek files are for averaging. Select optimal layer lines for aligning.  In each file select a few more LLs. 
# ex: cutfit1.dek=LL 5,6,11  cutfit2.dek=LL 5,6,10,11,17  cutfit3.dek=LL 1,5,6,10,11,17,28
# chop.dek files are for sniffing.  chop1.dek should have broader ranges than chop2.dek. Select a range over the meaningful portions on every LL except LL0. 
#
# LSF 11/5/09

# Remove description from phoelix_params to avoid set: Variable and syntax errors
cp phoelix_params temp_params
grep -v "set description" temp_params > phoelix_params
rm temp_params

source phoelix_params

# Copy individual files from stack into run directory
cp $rundir/partfiles/*/* $mandir

# Go to directory for mandatory files and put ll in order in llbo.sa
cd $mandir
sort -g llbo.tmp > llbo.sort
echo "LL BO"
cat llbo.sort
printf "\033[1 ; 34mIs the layer line/bessel order assignment correct? yes or no: "
printf "\033[0m"
set yn = $<
if ($yn == "no" || $yn == "n") then
	printf "\033[1 ; 34mDo you have an LL/BO file you would like to use? yes or no: "
	printf "\033[0m"
	set yn = $<
	if ($yn == "yes" || $yn == "y") then
		printf "\033[1 ; 31mNOTE: It must be in the proper llbo.sa format!\n"
		printf "\033[1 ; 34mEnter the filename including full path: \n"
		printf "\033[0m"
		set llbopath = $<
		printf "\033[1 ; 32mCopying $llbopath to $mandir/llbo.sa\n"
		printf "\033[0m"
		cp $llbopath $mandir/llbo.sa
	else if ($yn == "no" || $yn == "n") then
		printf "\033[1 ; 34mTry adjusting indexing parameters and/or repeat length and rerun.\n"
		printf "\033[0m"
		exit
	endif
else 
	cp llbo.sort llbo.sa
endif

## Transpose filaments from vertical to horizontal
ls -1 part*.mrc > transp.list
s_transpose transp.list

## Correct in-plane tilt
printf "\033[1 ; 32mAligning and centering filaments... \n"
printf "\033[0m" 
ls -1 *.tmrc > rot.list
s_testrot rot.list $padval

## Recenter and box out the filament segments 
ls -1 *.rot > box.list
loop:
s_autobox box.list $xlngth $yht2 $filval
printf "\033[1 ; 34mLook at the boxed out filaments, see if they are centered properly, then close Tkir window\n"
printf "\033[0m"
tkir -f *.s *.sbut
printf "\033[1 ; 34mDid the filaments get boxed and centered properly? yes or no: "
printf "\033[0m"
set yn = $<
if ($yn == "no" || $yn == "n") then
	printf "\033[1 ; 34mEnter a new filter value: "
	printf "\033[0m"
	set filval = $<
	goto loop
else if ($yn == "yes" || $yn == "y") then
	printf "\033[1 ; 36mGood! Remember filter value = $filval.\n"
	printf "\033[0m"
endif

## Correct tilt and shift using phoelix programs and create near and far files
printf "\033[1 ; 32mRunning Phoelix to correct tilt and shift... \n"
printf "\033[0m"
ls -1 *.s > maxi.list

touch selfile.list
set lines = `wc -l maxi.list | awk '{print $1}'`
set i = 1
while ($i <= $lines)
        set filex = `head -$i maxi.list | tail -1`
        set filep = `prefix $filex`
	pad -n $xlngth -p a <$filex | tomrc > $filep.smrc
	echo $rundir"/"$filep".smrc 1" >> selfile.list
@ i++
end

s_premaxi maxi.list
rm old*

## Average the near and far files 
# Do three round of averaging and two rounds of sniffing. 
ls -1 *.ner *.far > avg.list
if (!(-f template)) then
	cat avg.list
	printf "\033[1 ; 34mAbove is a list of your layer line files. Select one of these or one of your own to set as the template for the first iteration of averaging.\n"
	printf "\033[1 ; 31mNOTE: Include full path if not using a file above, and make sure it has the same number of LLs as in llbo.sa!\n"
	printf "\033[1 ; 34mEnter the exact filename: \n"
	printf "\033[0m"
	set template = $<
	printf "\033[1 ; 32mCopying $template to $mandir/template\n"
	printf "\033[0m"
	cp $template $mandir/template
else
	printf "\033[1 ; 34mTemplate already exists."
	printf "\033[0m"
endif

mkdir avgsnif1
cp *.ner *.far *params cutfit* chop* template avg.list avgsnif1
cd avgsnif1

## Round 1 of Averaging 
printf "\033[1 ; 34mGenerate 3 cutfit.dek files for iterative rounds of averaging by selecting the peak area on the strong layer lines.\n"
printf "\033[1 ; 34mFor the first round select 3-4 layer lines, then select 2-3 more for each additional round.\n"
printf "\033[1 ; 34mThen click File > Save Data > OK and close Tkll window.\n"
printf "\033[0m"
printf "\033[1 ; 32mDisplaying: tkll -f template -d cutfit1.dek -cut\n"
printf "\033[0m"
tkll -f template -d cutfit1.dek -cut
cp cutfit1.dek cutfit2.dek
printf "\033[1 ; 32mDisplaying: tkll -f template -d cutfit2.dek -cut\n"
printf "\033[0m"
tkll -f template -d cutfit2.dek -cut
cp cutfit2.dek cutfit3.dek
printf "\033[1 ; 32mDisplaying: tkll -f template -d cutfit2.dek -cut\n"
printf "\033[0m"
tkll -f template -d cutfit3.dek -cut

set filno = `wc -l avg.list | awk '{print $1}'`
printf "\033[1 ; 32mRound 1 of Averaging...\n"
printf "\033[0m" 
echo "Round 1: $filno filaments in avg.list" 
# Quick error check to make sure layer lines files are consistent
set cut1ll = `wc -l cutfit1.dek | awk '{print $1}'`
set cut2ll = `wc -l cutfit2.dek | awk '{print $1}'`
set cut3ll = `wc -l cutfit3.dek | awk '{print $1}'`
set templl = `grep LL template | wc -l`
if ($cut1ll != $cut2ll || $cut1ll != $cut3ll) then
	printf "\033[1 ; 31mERROR: cutfit.dek files do not have the same number of layer lines\n"
	printf "\033[0m"
	exit
else if ($cut1ll != $templl) then
	printf "\033[1 ; 31mERROR: template and cutfit.dek do not have the same number of layer lines\n"
	printf "\033[0m"
	exit
endif

s_fautoavg avg.list 3 avg1 template
cp template avglist3p.avg
cp template template.orig

# Generate overplots and map
s_fpost avg.list 3 $rescut postavg$rescut map overplot

# Split average lists into two lists and generate maps for estimating resolution using FSC
#s_splitlist avglist3_$rescut"p".list

set mrcpad = `ee $diameter : $step`
set mrcpad2 = `po2 -f $mrcpad`
pad -n $mrcpad2 <avglist3_$rescut"p".map> avglist3_$rescut"p".pad
tomrc <avglist3_$rescut"p".pad> avglist3_$rescut"p".mrc

cp avglist3_$rescut"p".avg template

# Prepare directory for Sniffing (s_presnif).  First step can be commented out if you already have chop1.dek.
s_chopper template
cp chop.dek chop1.dek
printf "\033[1 ; 34mRefine chop1.dek for the first round of sniffing by selecting the significant portions of each layer line.\n"
printf "\033[1 ; 34mThen click File > Save Data > OK and close Tkll window.\n"
printf "\033[1 ; 34mDo not select anything on layer line 0.\n"
printf "\033[0m"
printf "\033[1 ; 32mDisplaying: tkll -f template -d chop1.dek -cut\n"
printf "\033[0m"
tkll -f template -d chop1.dek -cut
s_llcut template snif_template.cut chop1.dek
cp ../*.fft .
cp ../*hlxdump* .
cp ../*hlxavg_dek .
ls -1 *.fft > snif.list

## Round 1 of Sniffing
# You should view the snif_template first, but for automation purposes it may be commented out.
printf "\033[1 ; 34mLook at snif_template and see if the layer lines got extracted properly.\n"
printf "\033[1 ; 32mDisplaying: tkll -f snif_template.cut\n"
printf "\033[0m"
tkll -f snif_template.cut
printf "\033[1 ; 34mDid it look okay? yes or no: "
printf "\033[0m"
set yn = $<
if ($yn == "no" || $yn == "n") then
	printf "\033[1 ; 34mReview chop1.dek and troubleshoot what went wrong. "
	printf "\033[0m"
endif
printf "\033[1 ; 32mRound 1 of sniffing...\n"
printf "\033[0m" 
set filno = `wc -l snif.list | awk '{print $1}'`
echo "Round 1: $filno filaments in snif.list" 

# Quick error check to make sure layer line files are consistent
set snifll = `grep LL snif_template.cut | wc -l`
set templl = `grep LL template | wc -l`
set templl1 = `ee $templl - 1`
if ($snifll != $templl1) then
	printf "\033[1 ; 31mERROR: template and chop.dek do not have the same number of layer lines\n"
	printf "\033[0m"
	exit
endif

s_sniffer snif.list
mkdir avgsnif2
cp *_snif.ner *_snif.far *params* cutfit* chop* avgsnif2
cp avglist3_$rescut"p".avg avgsnif2/template
cd avgsnif2
ls -1 *.ner *.far > avg.list

## Round 2 of Averaging
set filno = `wc -l avg.list | awk '{print $1}'`
printf "\033[1 ; 32mRound 2 of Averaging...\n"
printf "\033[0m" 
echo "Round 2: $filno filaments in avg.list" 
s_fautoavg avg.list 3 avg2 template
cp template avglist3p.avg

# Generate overplots and map
s_fpost avg.list 3 $rescut postavg$rescut map overplot

# Split average lists into two lists and generate maps for estimating resolution using FSC
#s_splitlist avglist3_$rescut"p".list

pad -n $mrcpad2 <avglist3_$rescut"p".map> avglist3_$rescut"p".pad
tomrc <avglist3_$rescut"p".pad> avglist3_$rescut"p".mrc

cp avglist3_$rescut"p".avg template

# Prepare directory for Sniffing (s_presnif).  First step can be commented out if you already have chop2.dek.
printf "\033[1 ; 34mGenerate chop2.dek for the second round of sniffing by selecting the significant portions of each layer line. Make ranges tighter than round 1.\n"
printf "\033[1 ; 34mThen click File > Save Data > OK and close Tkll window.\n"
printf "\033[1 ; 34mDo not select anything on layer line 0.\n"
printf "\033[0m"
printf "\033[1 ; 32mDisplaying: tkll -f template -d chop2.dek -cut\n"
printf "\033[0m"
cp chop1.dek chop2.dek
tkll -0 -f avglist3p.avg -d chop2.dek -cut
s_llcut template snif_template.cut chop2.dek
cp ../*.fft .
cp ../*hlxdump* .
cp ../*hlxavg_dek .
ls -1 *.fft > snif.list

## Round 2 of Sniffing
# You should view the snif_template first, but for automation purposes it may be commented out.
printf "\033[1 ; 34mLook at snif_template and see if the layer lines got extracted properly.\n"
printf "\033[1 ; 32mDisplaying: tkll -f snif_template.cut\n"
printf "\033[0m"
tkll -f snif_template.cut
printf "\033[1 ; 34mDid it look okay? yes or no: "
printf "\033[0m"
set yn = $<
if ($yn == "no" || $yn == "n") then
	printf "\033[1 ; 34mReview chop2.dek and troubleshoot what went wrong. "
	printf "\033[0m"
endif
printf "\033[1 ; 32mRound 2 of Sniffing...\n"
printf "\033[0m" 
set filno = `wc -l snif.list | awk '{print $1}'`
echo "Round 2: $filno filaments in snif.list" 

# Quick error check to make sure layer line files are consistent
set snifll = `grep LL snif_template.cut | wc -l`
set templl = `grep LL template | wc -l`
set templl1 = `ee $templl - 1`
if ($snifll != $templl1) then
	printf "\033[1 ; 31mERROR: template and chop.dek do not have the same number of layer lines\n"
	printf "\033[0m"
	exit
endif

s_sniffer snif.list
mkdir avg3
cp *_snif.ner *_snif.far *params* cutfit* chop* avg3
cp avglist3_$rescut"p".avg avg3/template
cd avg3
ls -1 *.ner *.far > avg.list

## Round 3 of Averaging
set filno = `wc -l avg.list | awk '{print $1}'`
printf "\033[1 ; 32mRound 3 of Averaging...\n"
printf "\033[0m" 
echo "Round 3: $filno filaments in avg.list" 
s_fautoavg avg.list 3 avg3 template

# Generate overplots and map
s_fpost avg.list 3 $rescut postavg$rescut map overplot

# Split average lists into two lists and generate maps for estimating resolution using FSC
#s_splitlist avglist3_$rescut"p".list

pad -n $mrcpad2 <avglist3_$rescut"p".map> avglist3_$rescut"p".pad
tomrc <avglist3_$rescut"p".pad> avglist3_$rescut"p".mrc

cp template cutfit*.dek chop*.dek $mandir

# Cleanup directory and leave only mandatory files
cd ../../../
rm -rf avgsnif1/* rejects/* part* old* avgsnif1 rejects autorot.out box.list max.temp hlxdump.dek llbo.sort llbo.tmp llbo.txt maxi.list rota4* rot.list selfile.list temp.col thread* final* avg.list greater.txt transp.list

printf "\033[1 ; 36mPreHIP Complete.  Mandatory files located in $mandir \n"
printf "\033[0m\n"
exit
