#!/bin/csh -f

source phoelix_params

rm -f $mandir/strong.sa $mandir/range.sa

set infile = $1
set lines = `wc -l $infile | awk '{print $1}'`
touch peaks.txt

# Calculate stats for collapsed diffraction file
set mean = `awk '{s+=$2}END{print s/NR}' $infile`
set var = `awk '{s+=($2 - x)^2}END{print s/NR}' x=$mean, $infile`
set stdev = `ee "sqrt[$var]"`
set nstdev = `ee [$stdev x 5] + $mean`

# Calculate layer line spacing and range to search around each predicted LL
set llspac = `ee "int[[$padval x $step] : $replen]"`
set range = `ee "int[$llspac : 2]"`
set stop = `ee "int[$lines : $llspac]"`
set i = 1
# Search at each predicted LL and find pix with greatest peak intensity
while ($i <= $stop)
	set peakpos = `ee [$llspac x $i] + 1`
	set headval = `ee $peakpos + $range`
	set tailval = $llspac
	head -$headval $infile | tail -$tailval > lines.txt
	set n = 1
	set comp = 0
	set peaktest = 0
	while ($n <= $llspac)
		set line = `head -$n lines.txt | tail -1`
		set peakht = `echo $line | awk '{print $2}'`
		set peakint = `ee "int[$peakht]"`
		if ($peakint > $comp) then
			set peakline = `echo $line`
			set peaktest = `echo $peakint`
			set comp = $peakint
			set n  = `ee $n + 1`
		else
			set n  = `ee $n + 1`
		endif
	end
	if ($peaktest != 0) then
		echo $peakline >> peaks.txt
	endif
	set peaktest = 0
	set i = `ee $i + 1`
end	

# Only keep the peaks with intensities greater than nstdev
awk '$2 > x' x=$nstdev peaks.txt > greater.txt
cp greater.txt temp.txt
set lines = `wc -l greater.txt | awk '{print $1}'`
set i = 1
# Make sure each layer line is only included once where peak intensity is greatest
while ($i < $lines)
	set pix = `head -$i greater.txt | tail -1 | awk '{print $1}'`	
	set pkht = `head -$i greater.txt | tail -1 | awk '{print $2}'`	
	set pkint = `ee "int[$pkht]"`
	set nexti = `ee $i +1`
	set nextpix = `ee $pix +1`
	set nextll = `head -$nexti greater.txt | tail -1 | awk '{print $1}'`
	set nextllint = `ee "int[$nextll]"`
	if ($nextllint == $nextpix) then
		set nextpk = `head -$nexti greater.txt | tail -1 | awk '{print $2}'`
		set nextpkint = `ee "int[$nextpk]"`
		if ($nextpkint > $pkint) then
			sed "/$pix/d" temp.txt > tmp
			cp tmp temp.txt
		else
			sed "/$nextll/d" temp.txt > tmp
			cp tmp temp.txt
		endif
	endif
	set i = `ee $i +1`
	end

mv temp.txt finalpks.txt
set lines = `wc -l finalpks.txt | awk '{print $1}'`
set i = 1
# Write strong.sa and range.sa
while ($i <= $lines)
	set pix = `head -$i finalpks.txt | tail -1 | awk '{print $1}'`
	set llspac = `ee [$padval x $step] : $replen`
	set ll = `ee "int[$pix : $llspac]"`
	if ($ll != 0) then
		set bo = `grep "ll=  $ll " $rundir/llbo.txt | awk '{print $4}'`
		set int = `ee "int[[$padval x $step] : $pix]"`
		echo $ll $bo $int >> $mandir/strong.sa
		set low = `ee "[abs[$bo] : 1000] - 0.003" | cut -c 0-8`
		set lowx = `ee $low x 1000000 | cut -d. -f1`
		if ($lowx <= 0) then	
			set low = 0.0001
		endif
		set high = `ee "[abs[$bo] : 1000] + 0.005" | cut -c 0-8`
		set highx = `ee $high x 1000000 | cut -d. -f1`
		set rmaxx = `ee $rmax x 1000000 | cut -d. -f1`
		if ($highx >= $rmaxx) then
			set high = `ee $rmax - 0.01`
		endif
		echo $ll $bo $low $high >> $mandir/range.sa
	endif
	set i = `ee $i +1`
	end

rm tmp peaks.txt lines.txt

