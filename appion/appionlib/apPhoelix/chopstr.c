/*
 *
 */

/* 
chopstr: Used to chop out small presumed straight pieces of a filament 
        located along a previously selected set of axis points.
        Works by locating the first point along the axis points and then 
        chopping out pieces xl in length after they are rotated to a 
        best straight line that fits through the chosen points.  Then
        the algorithm increments by xi along the points axis and chops
        out and rotates the next bit.  Note that this means that there could be 
        an overlap between chopped bits.

USAGE:   chopstr -f {input}  -d {input data file} -x0 {start x} -xl {length}
                -xi {increment} -y {ywidth} 
                -c {chop file basename}  -c {chop file extension}
 
INPUTS:
        -f {input} : File to be chopped up.  FLOAT format only.

	-d {input data file} : File containing inum, x, y values of points
        along the axis of the region of interest.  A good choice for these
	values is to use a set of splined points calculated by starting with
	a chosen set along an axis.  Splined points can be calculated using 
	spinec for example.

	-x0 : Starting point along the filament, usually 0.
	-xl : Length of chopped piece, will be padded or unpadded if necessary.
	-y : Width of chopped piece, will be padded out if necessary.
	-xi : Increment along the filament.  Default is xl.

        -c {chop file basename} : Basename for set of files that will 
		be generated by chopping up the input file into
		pieces xl in length.
	-x {chop file extension} : Extension for set of files that will
                be generated by chopping up the input file into
                pieces xl in length.
	-w {whole image flag} : Set this flag if you simply want to grab the
		entire area along the spline into a single rotated file.
	-quad : use quadratic interpolation.  Experimental, use at own risk!
		  Uses circular closure.
	-cubic : use bi-cubic interpolation.  Experimental, use at own risk!

OUTPUTS:
	A set of files called basename_###.extension where ### is a number
	starting at 000.

NOTES:
        Note that the algorithm will start chopping out straight bits 
        starting by default at the first point along the data set supplied 
        anid will end when the last bit is is less than xlen/2 long or it 
        runs out of data points along the spline.
        This is the best attempt I can think of to make sure we do not toss 
        out bits off the ends.

SEE:    'splinec', 'irmark', 'rotstr', 'findedges'

		Bridget Carragher, Urbana, IL, October 2000
*/

#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <math.h>
#include <hdr.h>
#include <img.h>
#include <ios.h>
#include <ras.h>
#include "str.h"

#if defined(_AIX) || SUN
#define fsin( x ) ( float )sin( ( double )( x ) )
#define fcos( x ) ( float )cos( ( double )( x ) )
#endif

#if  defined(__GNUC__)
#define fcos( x ) cosf( x ) 
#define fsin( x ) sinf( x ) 
#endif

#define icoor(x) x<0?0:(x>(nrow-1)?nrow-1:x)	/* smoutch() */
#define jcoor(x) x<0?0:(x>(ncol-1)?ncol-1:x)

#define SEPERATION	5			/* How close can two peaks
						 * be before getting 
						 * ruled as one
						 */

static void getargs( int narg, char **args, int *verbose, char *imgfile, char *dfile, char *cfilep, char *cfilex, float *x0, int *xlen, int *xi, int *ywidth, int *extrapolateflag, int *wflag, int *interpflag );



/* expects angle in radians */
static float rat( float **im, float **om, int nrow, int ncol,
				  float angle, float padval, int interpflag );

/* dflag set if you want degrees returned instead of radians */
static void linea( float data[2][ASIZE], int itot, float x0, int xl,
       int dflag, int yflag, float *angle, float *xmid, float *ymid );

static void interpimg( float **im, float **om, int nrow, int ncol,
					   double c1, double cn, double r1, double rn, int interpflag );

float interp( float **im, int nrow, int ncol, double y, double x,
                          double padval );

float cinterp( float **im, int nrow, int ncol, double y, double x,
                          double padval, float *answers );

float qinterp( float **im, int nydata, int nxdata, double y, double x,
                          double padval );

static void pad( float **im, float **om, int row, int col,
				 int newrow, int newcol, float padval );

/* Places peak value (x,y) into peak */
static float *rotstr_arc( float *vim, float *vtim, int col, int row,
						  double peakxy[2] );

static void smoutch( int nrow, int ncol, int msizer, int msizec,
					 float **im, float **om );

static void lsfit( float sdata[2][ASIZE], int n, float *cee, float *slope, float *stderror);

char		*progname = NULL;			/* str */
static FILE *fdd = NULL;


int main (int argc, char *argv[])
{
	HEAD	hdr;
	int	verbose = 0;
	char	imgfile[256];
	char    cfilep[256], cfilex[256];  
	char	dfile[256];
	char	ofile[256];
	char	fmt[256], string[256];
	int	ns = 0;
	int	fdi = 0;
	int	fdo = 0;
	float	*vim = NULL, *vom = NULL, *vom2 = NULL, *vrom = NULL;
	float	**im = NULL, **om = NULL, **om2 = NULL, **rom = NULL;
	float	data[2][ASIZE];
	int	nrow = 0, ncol = 0;
	int	erow = 0, ecol = 0;
	float	x0 = 0.0;
	float	cn = 0.0;
	float	angle =0.0, xmid = 0.0;
	int	xstart = 0, xend = 0, xlen = 0, xi = 0;
	int	ystart = 0, yend = 0, ywidth;
	float	ymid = 0.0;
	int	itot = 0;
	int	i = 0, dummy = 0;
	int	size = 0, esize, esize2;
	int	extrapolateflag = 0;/* If !0, retain first/last points */
	int	wflag = 0; /* just grab entire image as one piece */
	int	interpflag = 0; /* default is binlinear interpolation */
	float	padval = 0.0;
	float   x = 0.0, y = 0.0;
	int	filenum = 0;
	int	xgrab = 0, ygrab = 0;
	float x2 =0.0, y2 =0.0;

	progname = argv[0];

	getargs(argc, argv, &verbose, imgfile, dfile, cfilep, cfilex, &x0, &xlen, &xi, &ywidth, &extrapolateflag, &wflag, &interpflag);


	/*fprintf(stderr, "verbose = %d \n", verbose);
	/* read in filament */
	fdi = openfd(imgfile, "o");
	rhead (fdi, &hdr);
	if (hdr.intern != FLOAT)
		error("input image must be float","");
	nrow = hdr.nrow; ncol = hdr.ncol;
	size    = hdr.nrow * hdr.ncol;
	vim     = getimage(fdi, size, &hdr);
	im      = makef2d(hdr.nrow, hdr.ncol, vim);

        /* read in x, y values from dfile - output of tkir or str */
        fdd = efopen (dfile, "r");
        while ( (fscanf(fdd, "%d %f %f", &dummy, &x, &y) == 3)){
                data[0][itot] = x;
                data[1][itot] = y;
                itot++;
        }
        itot--;
	fclose(fdd);

	/* find the endpoints */
	if (wflag) {
		x0 = data[0][0];
		x2 = (data[0][itot] - data[0][0]) * (data[0][itot] - data[0][0]);
		y2 = (data[1][itot] - data[1][0]) * (data[1][itot] - data[1][0]);
		xlen = sqrt (x2 + y2);
		cn = data[0][0];
		xi = xlen;
	}
	else {
		if (x0 < data[0][0]) x0 = data[0][0];
		cn = (data[0][itot] - xlen/2.0);
		if (xi == 0) xi = xlen;
	}

	if (verbose) fprintf(stderr, "%d %f, %f \n", xlen, x0, cn); 
	if (verbose && interpflag == 1) fprintf(stderr, "Quadratic interpolation\n"); 

	while (x0 <= cn) {

		/* find angle and center point of line passing through
		   points between x0 and xlen */
		linea(data, itot, x0, xlen, 0, 0, &angle, &xmid, &ymid);	
		if (verbose) fprintf(stderr, "%f %f %f\n", angle, xmid, ymid);

		/* excise out a bit of the file, padded out 
		needs to be selected around the center point of the line chosen
		 and at the angle of the line */
/*
		xgrab = (int) ((1.1 * fcos(angle) * xlen/2.0) + ywidth/2.0);
		ygrab = (int) ((1.1 * fsin(angle) * xlen/2.0) + ywidth/2.0);
*/

		ygrab = abs ((int) ((fsin(angle) * xlen/2.0) - (fcos(angle) * ywidth/2.0)));
		xgrab = abs ((int) ((fcos(angle) * xlen/2.0) - (fsin(angle) * ywidth/2.0)));

		xgrab = (int) (1.5 * xgrab);
		ygrab = (int) (1.5 * ygrab);
		if (verbose) {
			fprintf(stderr,"angle = %f\n", angle);
			fprintf(stderr,"xlen = %d	ywidth = %d\n", xlen, ywidth);
			fprintf(stderr,"xgrab = %d	ygrab = %d\n", xgrab, ygrab);
		}

		if ((xmid - xgrab) < 0 || (xmid + xgrab) > ncol) 
			xgrab = MIN(xmid, ncol-xmid);
		if ((ymid - ygrab) < 0 || (ymid + ygrab) > nrow) 
			ygrab = MIN(ymid, nrow-ymid);

	        xstart = xmid - xgrab;
		xend = xmid + xgrab;
		ystart = ymid - ygrab;
		yend = ymid + ygrab;

 		erow = yend - ystart;
		ecol = xend - xstart;
		if (verbose) {
			fprintf(stderr,"xmid = %f	ymid = %f\n", xmid, ymid);
			fprintf(stderr,"xstart = %d	xend = %d\n", xstart, xend);
			fprintf(stderr,"ystart = %d	yend = %d\n", ystart, yend);
			fprintf(stderr,"erow   = %d	ecol = %d\n", erow, ecol);
		}

		esize 	= erow*ecol;
		vom	= f_alloc(esize);
		om	= makef2d(erow, ecol, vom);
		interpimg(im, om, nrow, ncol, xstart, xend, ystart, yend, interpflag);
		/* do some stats on om to get padval as average */
		dostat(vom, esize, &padval, &hdr.sd, &hdr.min, &hdr.max);
		/*fprintf(stderr, "min : %f max : %f\n", hdr.min, hdr.max);*/
                /* pad up before rotate */
                esize2 = nrow*ncol;
                vom2     = f_alloc(esize2);
                om2      = makef2d(nrow, ncol, vom2);
                pad(om, om2, erow, ecol, nrow, ncol, padval);

		/* rotate the excised bit by angle */
		vrom	= f_alloc(size);
		rom	= makef2d(nrow, ncol, vrom);
		rat(om2, rom, nrow, ncol, -angle, padval, interpflag);	
		
		/* unpad to xlen x ywidth */
		free(vom2);
		esize2 = ywidth * xlen;
                vom2     = f_alloc(esize2);
                om2      = makef2d(ywidth, xlen, vom2);
		pad(rom, om2, nrow, ncol, ywidth, xlen, padval);

		/* write out the excised bit */
		/* need to contruct the filename with a counter */
		sprintf(string,  "%s###%s", cfilep, cfilex);
		ns = getgef(string, cfilep, cfilex);
		sprintf(fmt, "%%s%%0%dd%%s", ns);
		sprintf(ofile, fmt, cfilep, filenum, cfilex);
		filenum++;

		if (wflag) fdo = openfd("stout", "");
		else fdo = openfd(ofile, "");

		hdr.nrow = ywidth;
		hdr.ncol = xlen;
		uphead (&hdr, argc, argv, fdtofnam(fdi));
		whead (fdo, &hdr);
		putimage (fdo, esize2, vom2, &hdr);
		closefd(fdo);

		/* increment up the filament and continue */
        	x0 = x0 + xi;

        	i++;

		fflush(NULL);

		free(om);
		free(vom);
		free(rom);
		free(vrom);

	}

	free(im);
	free(vim);
	return 0;
}

static void getargs( int narg, char **args, int *verbose, char *imgfile, char *dfile, char *cfilep, char *cfilex, float *x0, int *xlen, int *xi, int *ywidth, int *extrapolateflag, int *wflag, int *interpflag )
{
	char string[256];
	while (narg > 0) {
		if (strcmp ("-f", *args) == 0) {
			narg--;
			args++;
			strcpy(imgfile, *args);
		}
		else if (strcmp ("-d", *args) == 0) {
			narg--;
			args++;
			strcpy(dfile, *args);
		}
		else if (strcmp ("-c", *args) == 0) {
			narg--;
			args++;
			strcpy(string, *args);
			sprintf(cfilep, "%s.", string);
		}
		else if (strcmp ("-x", *args) == 0) {
			narg--;
			args++;
			strcpy(string, *args);
			sprintf(cfilex, ".%s", string);
		}
                else if(strcmp("-x0", *args) == 0) {
                        narg--;
                        args++;
                        *x0 = atof(*args);
                }
                else if(strcmp("-xl", *args) == 0) {
                        narg--;
                        args++;
                        *xlen = atoi(*args);
                }
                else if(strcmp("-xi", *args) == 0) {
                        narg--;
                        args++;
                        *xi = atoi(*args);
                }
                else if(strcmp("-y", *args) == 0) {
                        narg--;
                        args++;
                        *ywidth = atoi(*args);
                }
		else if (strcmp ("-x", *args) == 0) {
			*extrapolateflag = 2;
		}	
		else if (strcmp ("-w", *args) == 0) {
			*wflag = 1;
		}	
		else if (strcmp ("-quad", *args) == 0 ) {
			*interpflag = 1;
		}	
		else if (strcmp ("-quadri", *args) == 0 ) {
			*interpflag = 1;
		}	
		else if (strcmp ("-cubic", *args) == 0) {
			*interpflag = 2;
		}	
		else if (strcmp ("-v", *args) == 0) {
			*verbose = 1;
			fprintf(stderr, "verbose = %d \n", verbose);
		}	

		args++;
		narg--;
	}
}


static void linea( float data[2][ASIZE], int itot, float x0, int xl, int dflag, int yflag, float *angle, float *xmid, float *ymid)
{
	float	sdata[2][ASIZE];
	float	cee = 0.0, slope = 0.0, stderror = 0.0;
	int	j = 0, i = 0, stot = 0;
	float	theta = 0.0, x = 0.0, y = 0.0;

	sort(data, itot);
	norepeat(data, &itot);

	/* Find the points included in the line between x0 and xl */
	i = 0;
	for (i=0; i<itot; i++){
		if (x0 <= data[0][i] && (x0+xl >= data[0][i])) {
			sdata[0][j] = data[0][i]; 
			sdata[1][j] = data[1][i]; 
			j++; 
		}
	}
	stot = j;

/*
	for (i=0; i<stot; i++) fprintf(stderr, "i = %d sdata[0][i] = %f sdata[0][i] = %f\n", i, sdata[0][i], sdata[1][i]);
*/

	/* find the least squares best fit to a straight line */
        if (stot < 3) {
		if (stot == 0) {
			for (i=0; i<itot-1; i++){
                        if (x0 >= data[0][i] && x0 <= data[0][i+1]) {
				if (i<itot-2) {
                                sdata[0][0] = data[0][i];
                                sdata[1][0] = data[1][i];
                                sdata[0][1] = data[0][i+1];
                                sdata[1][1] = data[1][i+1];
				}
                                else {
                                sdata[0][0] = data[0][i-1];
                                sdata[1][0] = data[1][i-1];
                                sdata[0][1] = data[0][i];
                                sdata[1][1] = data[1][i];
                                }
			}
			}
		}
		if (stot == 1 ) {
		 	for (i=0; i<itot; i++){
                		if (sdata[0][0] == data[0][i]) {
				if (i < itot-1) {
                                sdata[0][1] = data[0][i+1];
                                sdata[1][1] = data[1][i+1];
				}
				else {
                                sdata[0][1] = sdata[0][0];
                                sdata[1][1] = data[1][0];
                                sdata[0][0] = data[0][i-1];
                                sdata[1][0] = data[1][i-1];
				}
                		}
        		}
		}
                slope = (sdata[1][1] - sdata[1][0])/(sdata[0][1] - sdata[0][0]);
                cee = sdata[1][1] - slope * (sdata[0][1]);
	}
	else 
		lsfit(sdata, stot, &cee, &slope, &stderror);

	theta = atan(slope);
	if (dflag)
		theta *= 180.0/M_PI;
	x = x0 + fcos(theta) * xl/2;
	y = cee + slope * x;
	*angle = theta; *xmid = x; *ymid = y;
	return ;
}

static void lsfit( float sdata[2][ASIZE], int n, float *cee, float *slope, float *stderror)
{
int	i= 0;
/*double  r = 0.0;*/
double	sx = 0.0 , sy = 0.0 , sx2 = 0.0, sy2 = 0.0, sxy = 0.0 ;
double  b0 = 0.0, b1 = 0.0, se = 0.0;
double	x =0.0, y = 0.0;

for (i=0; i<n; i++) {
	x= sdata[0][i]; y = sdata[1][i];
	sx += x; sy += y;
	sx2 += x*x; sy2 += y*y;
	sxy += x*y;
} 

/*r = (n * sxy - sx*sy)/(sqrt( (n*sx2 - sx*sx) * (n*sy2 - sy*sy) ));*/
b1 = (n * sxy - sx*sy)/(n*sx2 - sx*sx);
b0 = sy/n - b1*sx/n;

for (i=0; i<n; i++) {
	x= sdata[0][i]; y = sdata[1][i];
	se += (y - (b0+b1*x))*(y - (b0+b1*x));
}
se = (double) sqrt(se)/(n-2);

*cee = b0; *slope = b1; *stderror = se;

}

static float rat( float **im, float **om, int nrow, int ncol, float angle,
				  float padval, int interpflag )
{
	double  tm[3][3] = {{1.0, 0.0, 0.0}, {0.0, 1.0, 0.0}, {0.0, 0.0, 1.0}};
	int     x = 0, y = 0;
	int     ix = 0, iy = 0;
	double  dx = 0.0, dy = 0.0, rx = 0.0, ry = 0.0;
	int		nrm1 = nrow - 1;
	int		ncm1 = ncol - 1;
	int		mrow = nrow / 2;
	int		mcol = ncol / 2;
	float answers[3];

	rot_tm(tm, angle);
	inv_tm(tm);
	for (y=0; y < nrow; y++) {
		for (x=0; x < ncol; x++) {
			dx =  x - mcol;
			dy =  y - mrow;
			do_tm(tm, &dx, &dy);
			rx      =  dx + mcol;
			ry      =  dy + mrow;
			ix      = rx;
			iy      = ry;
			if (ix >= ncm1 || ix < 0 || iy >= nrm1 || iy < 0)
				om[y][x] = padval;
			else {
				if(interpflag==1)

					om[y][x] = qinterp(im, nrow, ncol, ry, rx, padval);
				else if (interpflag==2)
					om[y][x] = cinterp(im, nrow, ncol, ry, rx, padval, answers);
				else
					om[y][x] = interp(im, nrow, ncol, ry, rx, padval);
			}
		}
	}
	return 0.0;
}

static void interpimg( float **im, float **om, int nrow, int ncol,
					   double c1, double cn, double r1, double rn , int interpflag)
{
	int		i = 0, j = 0;
	int		icol = cn - c1;
	int		jrow = rn - r1;
	float	x = c1, y = 0.0;
	double	padval = im[0][0];	/* Pad with corner value */
	float answers[3];

	for (i=0; i<icol; i++){
		y = r1;
		for (j=0; j< jrow; j++){
#ifdef DEBUG
			fprintf(stderr,"i = %4d, j = %4d\n", i, j);
#endif
			if (interpflag==1)
		    		om[j][i] = qinterp(im, nrow, ncol, y, x, padval );
			else if (interpflag==2)
		    		om[j][i] = cinterp(im, nrow, ncol, y, x, padval, answers );
			else 
                                om[j][i] = interp(im, nrow, ncol, y, x, padval);
		    y = y + 1.0;
		}
		x = x + 1.0;
	}
}


static void pad( float **im, float **om, int row, int col,
				 int newrow, int newcol, float padval )
{
	int		i = 0, j = 0, in = 0, jn = 0;
	int		tpad = -(newcol - col) / 2;
	int		lpad = -(newrow - row) / 2;

	for (j=0; j < newrow; j++) {
		for (i=0; i < newcol; i++) {
			om[j][i] = padval;
		}
	}

	for (j=0; j < newrow; j++) {
		jn = j + lpad;
		if ((jn < 0) || (jn >= row))
			continue;
		for (i=0; i < newcol; i++) {
			in = i + tpad;
			if ((in < 0) || (in >= col))
				continue;
			om[j][i] = im[jn][in];
		}
	}
}


static void smoutch( int nrow, int ncol, int msizer, int msizec,
					 float **im, float **om )
{
	int		i = 0, j = 0, ic = 0, jc = 0, ik = 0, jk = 0;
	float	s = 0.0;
	int		skipc = msizec/2;
	int		skipr = msizer/2;
	float	m = msizer * msizec;

    for (i = 0; i < nrow; i++) {
        for (j = 0; j < ncol; j++) {
			s = 0.0;
			for (ik = -skipr; ik <= skipr; ik++)
				for (jk = -skipc; jk <= skipc; jk++) {
					ic = icoor (i + ik);
					jc = jcoor (j + jk);
					s += im[ic][jc];
				}
            s /= m;
            om[i][j] = s;
        }
    }
}


/* A stripped-down version of Nick's sipsArc function. */
/* No sips structures required. */

#define CTR_FLAG 1
#define ZERO_FLAG 0

/* Define these here to avoid the need for sips.h */
typedef float           float32;
typedef CPX             cplx_float32;   /* kluge to let us use CPX funtions */

static float *rotstr_arc( float *vmodel, float *vcan, int col, int row,
						  double peakxy[2])
{
	int		size = col * row;
	double	sx = 0.0, sy = 0.0;
	double	value = 0.0;
	float	radius = 1;
	int		lpf_radius = 0;
	float			**mod = NULL, *vrod = NULL, **rod = NULL;
	cplx_float32	*xcan = NULL, **xcan2 = NULL;
	cplx_float32	*xmod = NULL, **xmod2 = NULL;
	cplx_float32	*temp = NULL;

	/* ------------------------------ */
	/* Initialize and allocate memory */
	/* ------------------------------ */
	mod = (float **)makef2d(row, col, vmodel);
	vrod = (float *)malloc( sizeof(float32) * size);
	rod = (float **)makef2d(row, col, vrod);

	xcan = (cplx_float32 *)malloc( sizeof(cplx_float32) * size);
	xcan2 = (cplx_float32 **) make_cpx_2d(row, col, xcan);

	xmod = (cplx_float32 *)malloc( sizeof(cplx_float32) * size);
	xmod2 = (cplx_float32 **)make_cpx_2d(row, col, xmod);

	temp = (cplx_float32 *)malloc(sizeof(cplx_float32) * row);

	/* --------------------------------------- */
	/* Generate Fourier transform of candidate */
	/* --------------------------------------- */
	xdft(col, vcan, xcan2, &temp);

	if (lpf_radius != 0) {
		radius = (float)col/(float)lpf_radius;
		lbuttfil(col, col, xcan2, radius, (int) 1.0);
	}

	xdft(col, vmodel, xmod2, &temp); /* Fourier tranform of model */
	if (lpf_radius != 0) {
		lbuttfil(col, row, xmod2, radius, (int) 1.0);
	}

	xcor(col, ZERO_FLAG, CTR_FLAG, xcan, xmod, xmod); /* cross correlate */
	xdift(col, vrod, xmod2, temp); /* inverse fourier of xmod in rod */

	search_1_peak(col, row, rod, 0, 0, &sx, &sy, &value);
	peakxy[0] = sx;
	peakxy[1] = sy;

	free(xcan);
	free(xmod);
	free(temp);
	free(vrod);
	free(rod);
	free(xmod2);
	free(xcan2);
	free(mod);

	return(vrod);
}

