#!/bin/csh -f
#####
# s_finddell
# 	Searches for the intercepts of the "strong" layer lines listed in 
#	strong.specimen (eg. strong.tmv).  Format is: n l intercept(A)
#	If they are found then uses the n value to calcualte the layer line
#	spacing, dell,  as intercept/n.
#	Once complete for all peaks lised in strong.specimen, check if 
#	at least one worked, then calcualte and store dell as average of 
#	the ones found.  Check and flag a problem if the standard deviation
#	is too high.
# Note:  Pstrong1A is predicted intercept of peak stored in strong.specimen in A
#	 Pstrong1p is predicted intercept in pixels
#	 Fstrong1p is found intercept in pixels
#        Fstrong1A is found intercept in A
#	 and ditto for strong2, ... strongn
# Usage: s_finddell .pow .colb $filep.info strong.specimen 
# Input files: .pow .colb strong.specimen (specimen specific!)
# Output files: $filep.info  .sortout
#####

source phoelix_params

if ($s_verbose) echo `basename $0` $argv

set powfile = $1
set datafile = $2
set infofile = $3
set strongfile = $4

set filep = $datafile:r

set cols=`hdim -c < $powfile`

# Read in the n, l, intercepts for the strong peaks in strongfile
set numstrong = `wc -l $strongfile | awk '{print $1}'`
set i = 1

set line=`head -$i $strongfile | tail -1` 
set ll1p = `ee "[$cols x $step : $line[3]]"`
#set  range = `ee "int[[[$ll1p : $line[1]] : $rangefactor] + 0.5]"`
set range = 2

if ($range < 1) set range = 1
set ignore=`ee "int [$range : 2]"`
set avsd=`lstat -ns $ignore < $datafile`

# Search for strong peaks  
# Must set noglob for lpeaki output.  
if ($?noglob == 0) then
   set noglob_set = 0
   set noglob
else
   set noglob_set = 1
endif

set sumdell = 0
set sumnum = 0
# Search for strong LL (which might or might not be there)
while ($i <= $numstrong)
	set line=`head -$i $strongfile | tail -1` 
	set PiceptA = $line[3]
	set Piceptp = `ee "[$cols x $step : $PiceptA]"`
	set Ficeptp = 0
	set Ficeptp=`lpeaki -= $regno -p 1 -i $Piceptp -r $range $avsd -n $nsdev < $datafile | awk '{print $2}'`
	greater $Ficeptp 0 
	if (!($status)) then
		set sumdell = `ee "$sumdell + [$Ficeptp : $line[1]]"`
		@ sumnum++
		set FiceptA = `ee "[$cols x $step] : [$Ficeptp]"`
		echo "Predicted/Found peak search (pixels): " $Piceptp $Ficeptp
		echo "Predicted/Found peak search (A): " $PiceptA $FiceptA
		echo "Predicted/Found peak search (pixels): " $Piceptp $Ficeptp >> $filep.log
		echo "Predicted/Found peak search (A): " $PiceptA $FiceptA  >> $filep.log
	endif
	@ i++
end

if ($sumnum == 0) then
	echo $filep " Cannot find any peaks....stop processing"
	#remove the file from the list so it does not trip up processing later
	mv $filep.colb $filep.pow $filep.r1 $filep.rn $filep.s $filep.ss $filep.sub $filep.subbg $filep.tmp rejects
	stash $infofile $filep =$regno 0
else
	set dell = `ee "$sumdell : $sumnum"`
	stash $infofile $filep \=$regno $dell
	echo "stash $infofile $filep =$regno $dell"
	echo "Average layer line spacing ("$sumnum")" $dell
	echo "Average layer line spacing ("$sumnum")" $dell >> $filep.log
endif

if ($noglob_set == 0) then
   unset noglob
endif
