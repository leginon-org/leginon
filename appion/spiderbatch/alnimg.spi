(x25) ; particle radius
; Syntax: @alnimg(x25)
; Description: aligns images by one of four options.
; option1: APSR-only (free-align)
;  1) Align images to self (APSR)
; option2: APSR+APSH (free-align and orient with reference)
;  1) Align images to self (APSR)
;  2) Then align APSR average to reference image (APSH)
;  3) Combine alignment parameters
; option3: APSR+APSH+APSH (ref-align to oriented apsr average)
;  1) Align images to self (APSR)
;  2) Align APSR average to reference image (APSH)
;  3) Use aligned APSR average as reference (APSH)
; option4: APSH-only (align to reference)
;  1) Align images to reference (APSH)
;
; Output:
; 1) parameters to align averages in SAP format (<prefix>doc) 
;      SAP format is: pclnum,rt,x-sh,y-sh
; 2) stack containing the rotated averages (<prefix>@******)
; 3) average of aligned averages (<prefix>av and <prefix>va)
; 
; Some advice:
; Option1 is for alignment of images without reference bias
;         if you don't care about the orientation of the final average.
; Option2 is for alignment of images avoiding reference-bias (images never see a reference)
;         using the reference image only to orient the apsr average.
; Option3 is reference alignment of images to the oriented apsr average.  Images are
;         refaligned to their oriented apsr-average.
; Option4 is standard reference alignment of images (use refnm for multiref).

FR
?IN.Images template (dir/avg***)?<imgtmpl>
FR
?IN.Images list (dir/avglist)?<imglist>
RR x90
?IN.Alignment method (1=apsr,2=orientapsr,3=apsr2apsh,4=apsh)?
IF(x90.gt.1)THEN
  FR
  ?IN.Reference image (dir/img)?<refimg>
ENDIF
FR
?OUT.Prefix (dir/prefix for doc,av,va,@******)?<outpfx>

; ~~~~~ start ~~~~~

x23=x25*2 ;particle diameter
x30=0          ;zero
x24=1          ;one
x28=1          ;translation step size
x29=5          ;inner radius

UD N x21 ;how many averages
<imglist>
UD E
VM
echo -n Aligning {%F9.1%x21} images..

DOC SORT
<imglist>      ;input doc
<imglist>sort  ;output doc
(1)            ;sort by first column
Y              ;renumber keys

UD x21,x39     ;number of last average
<imglist>sort
UD E
DE
<imglist>sort

FS
<imgtmpl>x39
FI x27      ;size of images
<imgtmpl>x39
(2)

;---calculate search range---
x26=((x27/2)-x25-3)  ; search range = image radius - particle radius - 2
IF(x26.lt.0)THEN
  x25=int(x27/3) ;new radius
  x23=x25*2 ;new diameter
  x26=(int(x27/2)-x25-3)  ; search range = image radius - particle radius - 2
  VM
  echo Radius exceeds image dimension {%F7.1%x27}. Reset to {%F7.1%x25}.
ENDIF
;---calculate inner ring---
IF(x25.le.25)x29=3
IF(x25.le.10)x29=1

;---option 1, 2 and 3 start with apsr---
IF(x90.lt.4)THEN
  AP SR
  <imgtmpl>          ; Image series template
  <imglist>          ; Image list
  x23                ; Diameter
  x29,x25            ; FIRST AND LAST RING
  *                  ; Shape for centering
  <outpfx>tempi**    ; Output images template
  <outpfx>tempd**    ; Output transformation template

  ; find last apsr iteration
  VM
  ls <outpfx>tempi* | wc -w | nl -s ' 1  ' > <outpfx>temp.$DATEXT
  UD 1,x22
  <outpfx>temp
  UD E
  VM
  cp <outpfx>tempd{**x22}.$DATEXT <outpfx>apsrtemp.$DATEXT

  CP
  <outpfx>tempi{**x22}
  _2     ;apsrav

  VM
  rm -f <outpfx>temp*

  VM
  echo -n APSR..
ENDIF ; --option 1,2,or 3

;---option 2, 3 and 4 require apsh---
IF(x90.gt.1)THEN ;apsr+apsh,apsr=apsh or ref-only
  CP
  <refimg>
  _1
  SD 1,x30,x30,x30 ;psi,theta,phi=0
  <outpfx>angles_tmp
  SD E
  <outpfx>angles_tmp

  IF(x90.lt.4)THEN ;apsr+ref or apsr=ref
    AP SH
    _*    ; ref template
    (1)   ; ref number
    x26,x28     ; translation,step
    x29,x25     ; first,last radius
    <outpfx>angles_tmp  ; ref angles
    _*    ; image template
    (2)   ; image number
    *     ; experimental angles
    (0.0) ; no angular restriction
    (0)   ; no mirror
    <outpfx>pre
    DOC REN
    <outpfx>pre
    <outpfx>tmp
    DE
    <outpfx>pre

    ;    psi,tht,phi,ref,img,srt, sx, sy,prj,ang, cc,rt,x,y,mr
    UD 1,x81,x82,x83,x31,x36,x33,x34,x35,x84,x85,x32
    <outpfx>tmp
    UD E
    DE
    <outpfx>tmp
    VM
    echo -n APSR average rotated..

    IF(x90.eq.3)THEN ;apsr=ref
      RT SQ ; orient apsr-averge
      _2 ; apsr average
      _1
      x33,(1)
      x34,x35

      AP SH ; align images to oriented apsr-average
      _*    ; ref template
      (1)   ; refs
      x26,x28     ; translation,step
      x29,x25     ; first,last radius
      <outpfx>angles_tmp  ; ref angles
      <imgtmpl>   ; images template
      <imglist>   ; images
      *     ; experimental angles
      (0.0) ; no angular restriction
      (0)   ; no mirror
      <outpfx>pre
      DOC REN
      <outpfx>pre
      <outpfx>tmp
      DE
      <outpfx>pre

      VM
      echo -n Images aligned to average..
    ENDIF ; option3 - apsr+ref+ref
  ENDIF ; option 2 or 3 - apsr+ref

  IF(x90.eq.4)THEN ;ref-only
    AP SH
    _*    ; ref template
    (1)   ; refs
    x26,x28     ; translation search,step
    x29,x25     ; first,last radius
    <outpfx>angles_tmp  ; ref angles
    <imgtmpl>   ; images template
    <imglist>   ; images
    *     ; experimental angles
    (0.0) ; no angular restriction
    (0)   ; no mirror
    <outpfx>pre
    DOC REN
    <outpfx>pre
    <outpfx>tmp
    DE
    <outpfx>pre

    VM
    echo -n APSH..
  ENDIF ; option 4 - ref-only

  DE
  _1
  DE
  _2 ;apsrav
  DE
  <outpfx>angles_tmp

ENDIF ; apsr & ref-only

;---write alignment doc in sap format---
SD IC NEW   ;make incore output doc
alndoc_ic
(4),x21

MS I        ;make indexed stack for averages
_1@
x27,x27,x24 ;assumes square image
x21         ;how many images
x39         ;max image number

DO LB2 x12=1,x21 ;for each image
  UD IC x12,x40
  <imglist>

  IF(x90.lt.3)THEN ; first step was apsr
    UD IC x12,x41,x42,x43
    <outpfx>apsrtemp

    IF(x90.eq.2)THEN ;apsr+ref
      SA P x41,x42,x43
      x41,x42,x43  ; from apsrtemp
      x33,x34,x35  ; from apshtemp
    ENDIF
  ENDIF ;apsr-only or apsr+ref

  IF(x90.ge.3)THEN ;apsr=ref or ref-only
    ;         psi,tht,phi,ref,img,srt, sx, sy,sref,ang, cc,rt,x,y,mr
    UD IC x12,x81,x82,x83,x31,x36,x41,x42,x43,x84,x85,x32
    <outpfx>tmp
    IF(x36.ne.x40)THEN
      VM
      echo Error...<outpfx>tmp does not correspond with <imglist>
      EN
    ENDIF
  ENDIF

  RT SQ
  <imgtmpl>x40  ; input image
  _1@{******x40}      ; save over previous unaligned copy
  x41  ; angle
  x42,x43  ; xshift,yshift

  SD IC x12,x40,x41,x42,x43
  alndoc_ic
LB2 ; next average x12
UD ICE
<imglist>
SD IC COPY
alndoc_ic
<outpfx>doc
SD IC END
alndoc_ic

AS R
_1@******
<outpfx>doc
A
<outpfx>av
<outpfx>va

CP I
_1@        ;input index-stack of rotated images
<outpfx>@  ;output index-stack of rotated images
x39        ;max image number

DE
_1

IF(x90.lt.3)THEN
  UD ICE
  <outpfx>apsrtemp
  DE
  <outpfx>apsrtemp
ENDIF

IF(x90.ge.3)THEN
  UD ICE
  <outpfx>tmp
  DE
  <outpfx>tmp
ENDIF

VM
echo done.

RE
