[x25] ; particle radius
; ALNAVG[x25]
; -aligns images by one of three options.
;option1
; 1) ALIGN IMAGES TO SELF
;option2
; 1) THEN ALIGN APSR AVG TO REFIMAGE
; 2) COMBINE ALIGNMENT PARAMETERS
;option3
; 1) ALIGN IMAGES TO REFIMAGE
; 
; Output
; 1) parameters to align averages in SAP format (<prefix>doc)
; 2) stack containing the rotated averages (<prefix>@******)
; 3) average of aligned averages (<prefix>av and <prefix>va)

FR
?IN.IMAGE TEMPLATE (dir/avg***)?<imgtmpl>
FR
?IN.IMAGE LIST (dir/avglist)?<imglist>
RR x90
?IN.ALIGNMENT METHOD (1=apsr,2=apsr+ref,3=ref)?
IF(x90.gt.1)THEN
FR
?IN.REFERENCE IMAGE (dir/img)?<refimg>
ENDIF
FR
?OUT.OUTPUT PREFIX (dir/prefix for doc,av,va,@******)?<outpfx>

; ~~~~~ start ~~~~~

x23=x25*2 ; particle diameter
x24=1 ; need to start at 1
x28=1 ; translation step size
x29=5 ; inner radius
x30=0 ; zero

UD N x21 ;how many averages
<imglist>
VM
echo -n Aligning {%F7.1%x21} images..

DOC SORT
<imglist>      ;input doc
<imglist>sort  ;output doc
(1)            ;sort by first column
Y              ;renumber keys
UD x21,x39  ;number of last average
<imglist>sort
UD E
DE
<imglist>sort
FS
<imgtmpl>x39
FI x27      ;size of images
<imgtmpl>x39
(2)

; calculate search range
x26=((x27/2)-x25-2)  ; search range = image radius - particle radius - 2
IF(x26.lt.0)x26=0    ; search range must be nonnegative

IF(x25.lt.x29)THEN   ; if outer radius is less than inner ring
x25=(x27/2)-2   ; reset radius to half image size
ENDIF

IF(x25.lt.x29)x29=0  ; if outer ring is still less than inner, resize inner

; --- option 1 and 2
IF(x90.lt.3)THEN ; use apsr for alignment
AP SR
<imgtmpl>          ; Image series template
<imglist>          ; Image list
x23                ; Diameter
x29,x25            ; FIRST AND LAST RING
*                  ; Shape for centering
<outpfx>tempi**    ; Output images template
<outpfx>tempd**    ; Output transformation template

VM
echo -n APSR complete..
; find last apsr iteration
VM
ls <outpfx>tempi* | wc -w | cut -c 1-7 | nl -s ' 1  ' > <outpfx>temp.$DATEXT
UD 1,x22
<outpfx>temp
VM
cp <outpfx>tempd{**x22}.$DATEXT <outpfx>apsrtemp.$DATEXT
CP
<outpfx>tempi{**x22}
_2
VM
rm -f <outpfx>temp*
ENDIF ;apsr-only or apsr+ref

; --- option 2 and 3
IF(x90.gt.1)THEN ;apsr+ref or ref-only
SD IC NEW
apshangles_ic
(3,1)
SD IC 1,x30,x30,x30 ;psi,theta,phi
apshangles_ic

CP
<refimg>
_1

IF(x90.eq.2)THEN ;apsr+ref
;AP SH
;_*    ; ref template
;(1)   ; refs
;x26,x28     ; translation search,step
;x29,x25     ; first,last radius
;apshangles_ic  ; ref angles
;_*    ; images template
;(2)   ; images
;*     ; experimental angles
;(0.0) ; no angular restriction
;(0)   ; no mirror
;<outpfx>pre
;DOC REN
;<outpfx>pre
;<outpfx>tmp
;DE
;<outpfx>pre
;psi,theta,phi,ref,img,sumrt,sumx,sumy,numprj,ang,cc,rt,x,y,mr
;UD IC 1,x81,x82,x83,x31,x36,x33,x34,x35,x84,x85,x32
;<outpfx>tmp

AP NQ
_*     ; reference template
(1)    ; reference number
x26,x28     ; CHANGE this !!! SEARCH RANGE AND STEP SIZE
x29,x25     ; CHANGE this !!! FIRST AND LAST RING
_*  ;average template
(2) ;average index
<outpfx>tmp ;outputdoc

UD IC 1,x31,x32,x33,x34,x35,x36 ;ref,cc,rt,x,y,num
<outpfx>tmp

DE
_2
VM
echo -n APNQ complete..
ENDIF ; option 2 - apsr+ref

IF(x90.eq.3)THEN ;ref-only
;AP SH
;_*    ; ref template
;(1)   ; refs
;x26,x28     ; translation search,step
;x29,x25     ; first,last radius
;apshangles_ic  ; ref angles
;<imgtmpl>   ; images template
;<imglist>   ; images
;*     ; experimental angles
;(0.0) ; no angular restriction
;(0)   ; no mirror
;<outpfx>pre
;DOC REN
;<outpfx>pre
;<outpfx>tmp
;DE
;<outpfx>pre

AP NQ
_*     ; reference template
(1)    ; reference number
x26,x28       ; CHANGE this !!! SEARCH RANGE AND STEP SIZE
x29,x25       ; CHANGE this !!! FIRST AND LAST RING
<imgtmpl>  ;image template
<imglist>  ;image index
<outpfx>tmp

VM
echo -n APNQ complete..

ENDIF ; option 3 - ref-only

DE
_1

SD IC END
apshangles_ic

ENDIF ; apsr & ref-only

; --- write alignment doc in sap format
UD N x21 ;how many averages
<imglist>
SD IC NEW   ;make incore output doc
outalndoc
(4),x21
MS I        ;make indexed stack for averages
_1@
x27,x27,x24 ;assumes square image
x21         ;how many images
x39         ;max image number

DO LB2 x12=1,x21 ;for each image
UD IC x12,x40
<imglist>

IF(x90.lt.3)THEN ; first step was apsr
UD IC x12,x41,x42,x43
<outpfx>apsrtemp
ENDIF ;apsr-only or apsr+ref

IF(x90.eq.2)THEN ;apsr+ref
SA P x41,x42,x43
x41,x42,x43  ; from apsrtemp
x33,x34,x35  ; from apnqtemp
ENDIF

IF(x90.eq.3)THEN ;ref-only
;UD IC x12,x81,x82,x83,x31,x36,x41,x42,x43,x84,x85,x32
UD IC x12,x31,x32,x41,x42,x43,x36
<outpfx>tmp
ENDIF

RT SQ
<imgtmpl>x40  ; input image
_1@{******x40}      ; save over previous unaligned copy
x41  ; angle
x42,x43  ; xshift,yshift

SD IC x12,x40,x41,x42,x43
outalndoc

LB2 ; next average x12

AS R
_1@******
outalndoc
A
<outpfx>av
<outpfx>va

CP I
_1@        ;input index-stack of rotated images
<outpfx>@  ;output index-stack of rotated images
x39        ;max image number

SD IC COPY
outalndoc
<outpfx>doc
SD IC END
outalndoc
UD ICE
<imglist>

IF(x90.lt.3)THEN
UD ICE
<outpfx>apsrtemp
DE
<outpfx>apsrtemp
ENDIF

IF(x90.gt.1)THEN
UD ICE
<outpfx>tmp
DE
<outpfx>tmp
ENDIF

VM
echo done.
RE
