(x20) ; (radius)
; Syntax: @mrgvolbyprj(radius)
; Description: match projections and merge volumes
;  projects volumes and matches using apsh
;  rotates volumes then calculates ccc and matches to best volume
;  uses this angle to merge volume with its nearest match
; Output: volmergedoc

FR
?IN.List of reference volumes (dir/list)?<reflist>
FR
?IN.List of volumes to merge (dir/list)?<mergelist>
FR
?IN.Volume template (dir/fvol***)?<voltmpl>
FR
?OUT.Directory to put results (dir)?<dir>

; ~~~~~ start ~~~~~
x19=0 ; merged volume counter

; --- module 1: match each class average with projections of each volume ---
VO EA
(10)    ; every 10 degrees (seems to be sufficiently accurate)
(0,90)
(0,359.9)
<dir>/angles

UD N x21
<reflist>
UD N x22
<mergelist>
UD N x23
<dir>/angles

;store cc matrix in image
BL
_1
x21,x21,(1)  ;refvols,mergevols
N   ; input density
(0) ; density

UD IC x21,x30
<reflist>
FS
<voltmpl>x30
FI x24 ;volume size
<voltmpl>x30
(12)

x24=x23/2-x20-2 ; translation range
IF(x24.lt.0.0)x24=0
x25=5           ; inner radius
IF(x20.le.20)x25=2
IF(x20.le.10)x25=0

DO LB1 x11=1,x21  ; for each volume
  UD IC x11,x30
  <reflist>

  PJ 3Q
  <voltmpl>x30 ; reference volume x30
  x20
  (1-x22)
  <dir>/angles
  <dir>/prj{***x30}@***

  AP SH
  <dir>/prj{***x30}@***
  (1-x22)
  x24,(1)       ;translation,step
  x25,x20       ;inner,outer radius
  <dir>/angles  ;angles of prjs
  <avgtmpl>     ;images to align
  <list>        ;
  *             ;no current angles of images
  (0.0)         ;no restriction
  (1)           ;check mirror
  <dir>/apsh_vol{***x30}tmp

  DE
  <dir>/prj{***x30}

  DOC REN
  <dir>/apsh_vol{***x30}tmp
  <dir>/apsh_vol{***x30}
  DE
  <dir>/apsh_vol{***x30}tmp

  DO LB2 x12=1,x21 ; for each average write cc to image
    ;         psi,tta,phi,prj,avg,rot,xsh,ysh,tot,dif,cc
    UD IC x12,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41
    <dir>/apsh_vol{***x30}

    RP
    _1
    x11,x12  ;vol in column,avg in row
    x41

  LB2
  UD ICE
  <dir>/apsh_vol{***x30}

LB1 ; for each volume
DE
<dir>/angles

;CP
;_1
;<dir>/cc_avgvsvol

; --- module 2: identify best match for each class average ---

SD /       AVG# MATCHES VOL#  WITH  CCMAX AT PRJ   PHI         TTA          PSI
<dir>/matchdoc
; now aside from its own volume what is next closest
DO LB3 x13=1,x21 ; for each average
  UD IC x13,x30
  <list>

  LI D
  _1
  <dir>/cc_tmp{***x30}
  R ; column (avg)
  x13
  DOC SORT
  <dir>/cc_tmp{***x30}
  <dir>/cc_avg{***x30}
  (1) ; by cc
  Y
  DE
  <dir>/cc_tmp{***x30}

  ;        ,cc ,col,row,slc
  UD IC x21,x45,x46,x47,x48
  <dir>/cc_avg{***x30}
  IF(x47.eq.x13)THEN ; average matches its volume best
    x29=x21-1
    UD IC x29,x45,x46,x47,x48
    <dir>/cc_avg{***x30}
  ENDIF
  UD ICE
  <dir>/cc_avg{***x30}
  DE
  <dir>/cc_avg{***x30}
  UD IC x46,x49  ; read volnum from list
  <list>
  VM
  echo Average {%F7.1%x30} matches Volume {%F7.1%x49} with CC={%F7.2%x45}

  ;      psi,tta,phi,prj,avg,rot,xsh,ysh,tot,dif,cc
  UD x13,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41
  <dir>/apsh_vol{***x49}
  UD E
  IF(x35.ne.x30)THEN
    VM
    echo Error...apsh_vol{***x49} does not correspond with <list>
    EN
  ENDIF
  x50=abs(x41-x45)
  IF(x50.gt.0.05)THEN
    VM
    echo Error...apsh_vol{***x49} has different CC value than cc_avg{***x30}
    EN
  ENDIF

  ; calculate rotation of average required to align with projection
  x36=360-x36 ;psi=-psi in plane rotation of prj instead of avg
  ;     ,avg,vol,cc ,phi,tta,psi
  SD x13,x30,x49,x41,x33,x32,x36
  <dir>/matchdoc

  ;generate prj{***x30} that matches avg{***x30}
  SD 1,x36,x32,x33
  <dir>/anglestmp
  SD E
  <dir>/anglestmp
  PJ 3Q
  <voltmpl>x49
  x20
  (1)
  <dir>/anglestmp
  <dir>/tmpprj***
  CP
  <dir>/tmpprj001
  <dir>/prj{***x30}
  DE
  <dir>/tmpprj001
  DE
  <dir>/anglestmp

LB3 ; next class-average
UD ICE
<list>
SD E
<dir>/matchdoc

DE
_1 

; --- module 3: determine relevant matches and angles ---
; strategy 1: find mutual matches (avgA matches volB and avgB matches volA)

; strategy 2: find avgs and vols that match with opposite angles
; angle(avgA:volB)+angle(avgB:volA)~0
SD /      Vol# Merged With Vol#     PHI     TTA      PSI 
<dir>/volmergetmp

;store merges in image
BL
_1
x21,(1),(1)
N   ; input density
(0) ; density

DO LB4 x14=1,x21 ; for each average

  ; find projection angle of vol(x32) that best matches avg(x31)
  UD IC x14,x31,x32,x33,x34,x35,x36
  <dir>/matchdoc

  ; find projection angle of vol(x31) that best matches avg(x32) 
  DO LB5 x15=1,x21 ; for each average
    ;         psi,tta,phi,prj,avg,rot,xsh,ysh,tot,dif,cc
    UD IC x15,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50
    <dir>/apsh_vol{***x31}
    IF(x44.eq.x32)GOTO LB91 ; found average x32 in vol x31
  LB5
  VM
  echo Error...Average {***x32} was not found in apsh_vol{***x31}
  GOTO LB92 ; next average

  LB91
  x45=360-x45 ; psi=-psi
  ; angle(avgA:volB)+angle(avgB:volA)~0
  ; A,B,C should be reversed by -C,-B,-A
  SA E x51,x52,x53
  x34,x35,x36
  x45,x41,x42 ;x42,x41,x45

  ; Is this angle close to 0? (within 10 degrees)?
  ; vector in cartesian coordinates
  x61=1 ;x
  x62=0 ;y
  x63=0 ;z
  ; transform vector by phi,tta,psi
  ;phi=x51
  x64=((x61*cos(x51))+(x62*sin(x51))+(x63*0))
  x65=((-x61*sin(x51))+(x62*cos(x51))+(x63*0))
  x66=((x61*0)+(x62*0)+(x63*1))
  ;tta=x52
  x64=((x64*cos(x52))+(x65*0)+(-x66*sin(x52)))
  x65=((x64*0)+(x65*1)+(x66*0))
  x66=((x64*sin(x52))+(x65*0)+(x66*cos(x52)))
  ;psi=x53
  x64=((x64*cos(x53))+(x65*sin(x53))+(x66*0))
  x65=((-x64*sin(x53))+(x65*cos(x53))+(x66*0))
  x66=((x64*0)+(x65*0)+(x66*1))
  ; find angular distance between vector A (x61,x62,x63) and vector B (x64,x65,x66)
  ; v1.v2=|v1||v2|cos(A)
  x67=aco((x61*x64)+(x62*x65)+(x63*x66))
  VM
  echo -n Avg{***x31} to Vol{***x32}' - 'Avg{***x32} to Vol{***x31} is {%F7.2%x67} degrees

  IF(x67.le.20.0)THEN
    VM
    echo ...Will rotate Vol{***x31} to combine with Vol{***x32}

    ; vol x31 rotated by phi,tta,psi to merge with vol x32
    x19=x19+1 ; only write matches
    SD x19,x31,x32,34,x35,x36
    <dir>/volmergetmp

  ELSE
    VM
    echo ...Not similar enough to merge
  ENDIF

  LB92 ; skip this average
  UD ICE
  <dir>/apsh_vol{***x31}

LB4 ; next average x31
UD ICE
<dir>/matchdoc
SD E
<dir>/volmergetmp

; --- module 4: check for heirarchy of volume mergers ---
SD /      Vol# Merged W Vol#       PHI        TTA        PSI 
<dir>/volmergedoc
DOC REN
<dir>/volmergetmp
<dir>/volmergeren
UD N x26
<dir>/volmergeren
IF(x26.eq.x19)THEN
VM
echo ~~~ {%F7.1%x26} volumes will be merged ~~~
ELSE
VM
echo Error...{%F7.1%x26} volumes written but {%F7.1%x19} should be merged.
EN
ENDIF

x19=0 ; reset merged volume counter
DO LB6 x16=1,x26 ; for each merged volume
  x20=1 ;number of merges
  x99=0 ;exit status

  UD IC x16,x31,x32,x33,x34,x35
  <dir>/volmergeren
  x30=x31
  VM
  echo -n Vol{***x30} matches Vol{***x32}

  ; now check to see what x32 matches
  DO LB8 x18=1,x26 ; restart search for new x32

    DO LB7 x17=1,x26 ; search for x32
      UD IC x17,x36,x37,x38,x39,x40
      <dir>/volmergeren
      IF(x99.eq.1)GOTO LB95 ; exit by running loop
      IF(x36.eq.x32)THEN ; avg x32 matches volume x37
        IF(x37.eq.x31)THEN ; circular match (use cc to decide which is better)
          UD N x27
          <dir>/matchdoc
          DO LB9 x11=1,x27
            UD IC x11,x41,x42,x43,x44,x45,x46
            <dir>/matchdoc
            IF(x41.eq.x31)x47=x43  ; avgA:volB cc
            IF(x41.eq.x32)x48=x43  ; avgB:volA cc
          LB9
          UD ICE
          <dir>/matchdoc
          IF(x47.gt.x48)THEN ;avgA:volB was better match than avgB:volA
            VM
            echo -n ' 'keep avg{***x31}:vol{***x32} {%F7.1%x47} and remove avg{***x32}:vol{***x31} {%F7.1%x48}
            x99=1 ;exit indicator
          ELSE ;avgB:volA was better match than avgA:volB
            x20=x20-1 ; not matched
            x99=1 ;exit indicator
          ENDIF ; avgA > avgB
        ELSE ; match not circular
          VM
          echo -n ' matches 'Vol{***x37}
          SA E x33,x34,x35
          x33,x34,x35
          x38,x39,x40
          x32=x37
          x31=x36
          x20=x20+1
        ENDIF ; circular match
      ENDIF ; x32=x36
      LB95 ;exit by running loop
    LB7

  LB8

  IF(x20.ge.1)THEN
    VM
    echo -n ' saved'
    x19=x19+1
    SD x19,x30,x32,x33,x34,x35
    <dir>/volmergedoc

    RT 3D
    <voltmpl>x30
    <dir>/newvol{***x30}
    x33,x34,x35

  ELSE
    VM
    echo -n ' but not saved'
  ENDIF

  VM
  echo '.'

LB6 ; next volume to merge

UD ICE
<dir>/volmergeren
DE
<dir>/volmergetmp
DE
<dir>/volmergeren
SD E
<dir>/volmergedoc

; write euler angles for untilted images
; rewrite euler angles for tilted images
; generate merged volume by backprojection and refinement

RE
