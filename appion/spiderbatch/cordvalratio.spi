; calculates ratio between pixels in two regions of an image
FR
?IN.COORDINATE FILE (dir/cords)?<cords>
RR x20
?IN.RADIUS (2)?;<radius>
FR
?IN.LIST OF IMAGES (dir/list)?<list>
FR
?IN.IMAGE TEMPLATE (dir/tmpl***)?<tmpl>
FR
?OUT.OUTPUT SORTED RATIO DOC (dir/doc)?<outdoc>

; ~~~~~ start ~~~~~

;x20=<radius>

UD 1,x21,x22 ;nsam,nrow
<cords>
UD 2,x23,x24 ;nsam,nrow
<cords>

x30=x21-x20 ;min nsam1
x31=x21+x20 ;max nsam1
x32=x22-x20 ;min nrow1
x33=x22+x20 ;max nrow1
x34=x23-x20 ;min nsam2
x35=x23+x20 ;max nsam2
x36=x24-x20 ;min nrow2
x37=x24+x20 ;max nrow2
;VM
;echo Coordinate 1 top left is {%F7.1%x30},{%F7.1%x32} bottom right is {%F7.1%x31},{%F7.1%x33}
;VM
;echo Coordinate 2 top left is {%F7.1%x34},{%F7.1%x36} bottom right is {%F7.1%x35},{%F7.1%x37}

x19=(1)
IF(x30.lt.x19)THEN
 VM
 echo Radius of coordinate 1 extends beyond left edge
 GOTO LB99
ENDIF
IF(x32.lt.x19)THEN
 VM
 echo Radius of coordinate 1 extends above top edge
 GOTO LB99
ENDIF
IF(x34.lt.x19)THEN
 VM
 echo Radius of coordinate 2 extends beyond left edge
 GOTO LB99
ENDIF
IF(x36.lt.x19)THEN
 VM
 echo Radius of coordinate 2 extends above top edge
 GOTO LB99
ENDIF

UD x19,x26
<list>
FS
<tmpl>x26
FI x27,x28
<tmpl>x26
(12),(2) ; nsam,nrow
IF(x31.gt.x27)THEN
 VM
 echo Radius of coordinate 1 extends beyond right edge
 GOTO LB99
ENDIF
IF(x33.gt.x28)THEN
 VM 
 echo Radius of coordinate 1 extends below bottom edge
 GOTO LB99
ENDIF
IF(x35.gt.x27)THEN
 VM
 echo Radius of coordinate 2 extends beyond right edge
 GOTO LB99
ENDIF
IF(x37.gt.x28)THEN
 VM
 echo Radius of coordinate 2 extends below bottom edge
 GOTO LB99
ENDIF

;x18=(2)
;x19=((x20+1)*(x20+1))
;VM
;echo writing temporary {%F7.1%x18} registers and {%F7.1%x19} keys
;SD IC NEW
;tempcords1
;x18,x19
;SD IC NEW
;tempcords2
;x18,x19

x19=(0.5)
x38=0 ;counter
DO LB2 x12=x30,x31 ; for each nsam
DO LB3 x13=x32,x33 ; for each nrow

x40=SQR(((x12-x21)**2)+((x13-x22)**2)) ; distance from cord to pixel
x41=x40-x20 ; distance minus radius 

IF(x41.lt.x19)THEN ; ignore if more than half pixel longer than radius
x38=(x38+1)
;SD IC x38,x12,x13 ;
SD x38,x12,x13
tempcords1
ENDIF

LB3
LB2

VM
echo {%F7.1%x38} pixels within radius {%F7.1%x20} from first coordinate {%F7.1%x21},{%F7.1%x22}

x39=0
DO LB4 x14=x34,x35 ; for each nsam
DO LB5 x15=x36,x37 ; for each nrow

x40=SQR(((x14-x23)**2)+((x15-x24)**2)) ; distance from cord to pixel
x41=(x40-x20) ; distance minus radius

IF(x41.lt.x19)THEN
x39=(x39+1)
;SD IC x39,x14,x15 ;
SD x39,x14,x15
tempcords2
ENDIF

LB5
LB4

VM
echo {%F7.1%x39} pixels within radius {%F7.1%x20} from second coordinate {%F7.1%x23},{%F7.1%x24}

UD N x25
<list>
UD E
;SD IC NEW
;tempratios
;(4),x25
;VM
;echo Written in-core file to receive ratios 4 registers and for {%F7.1%x25} images

DO LB1 x11=1,x25
UD IC x11,x26
<list>

; cannot have negative values - use minimum value of image for additive factor
FS
<tmpl>x26
FI x27
<tmpl>x26
(8) ; min

;VM
;echo -n Image {%F7.1%x26}...coordinate 1
x42=(0)
DO LB6 x16=1,x38 ; for each pixel around coordinate 1

UD IC x16,x12,x13
tempcords1

GP x43
<tmpl>x26
x12,x13 ;nsam,nrow

x43=x43-x27 ; adjust value for minimum
x42=x42+x43 ; increment sum
LB6

;VM
;echo -n ' 'over coordinate 2
x44=0
DO LB7 x17=1,x39 ; for each pixel around coordinate 2

UD IC x17,x14,x15
tempcords2

GP x45
<tmpl>x26
x14,x15 ;nsam,nrow

x45=x45-x27 ; adjust value for minimum
x44=x44+x45 ; increment sum
LB7

x42=x42/x38 ; average intensity 1
x44=x44/x39 ; average intensity 2
x46=x42/x44 ; ratio of 1 to 2

;VM
;echo ...ratio {%F7.3%x46}

;SD IC x11,x26,x46,x42,x44 ; 
SD x11,x26,x46,x42,x44 ; imagenum,ratio,value1,value2
tempratios

LB1 ; next image x11
UD ICE
<list>
UD ICE ;SD IC END
tempcords1
UD ICE ;SD IC END
tempcords2
DE 
tempcords1
DE 
tempcords2

DOC SORT
tempratios
<outdoc>
(2)

VM
echo List sorted by ratio of coord-1 vs coord-2 ... <outdoc>

UD ICE
tempratios
DE ;SD IC END
tempratios

LB99
RE
