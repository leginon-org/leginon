; Description: preprocess particles
;   1) center all particles based on their average (integer shift)
;       tip: window particles a little large then crop after centering
;   2) interpolate/crop
;   2) normalize
;   3) filter 
;   4) mask corners with radius = 3/5*boxsize
; Output:
;   c<stack>av, c<stack>va = average and variance of crop/interpolated/centered particles
;   n<stack> = normalized-cropped/interpolated-centered particle stack
;   fn<stack> = filtered particle stack
;   mfn<stack> = masked/filtered particle stack
; version 20090717

FR L   ;directory containing particles
<pcldir>pcl

FR L   ;particle stackname in ./pcldir (assumes @******)
<stack>seru

FR L   ;particle list (will make if doesn't exist)
<list>pcl/serulist

RR x24 ;pixelsize (A/pixel)
2.1   ;used to calculate interpolation and filtration

; ---- Interpolate ----
RR x25 ;interpolated pixelsize (A/pixel)
4.2    ;enter 0 to skip interpolation

; ---- Crop ----
;Boxsize tip: = 1.5 * particle diameter, avoid factors of large prime numbers
RR x20 ;cropped boxsize (pixels)
0     ;enter 0 to skip crop

; ---- Normalize ----
RR x40 ;mean pixel intensity
500

RR x41 ;stdev (usually about 10% of mean)
50     ;enter 0 to skip normalization

; ---- Filter ----
;Filter tips:
;  particle is stained, lp >= 18A
;  my particle is 200A diameter, hp = 200A * 1.4 >= 280A

RR x22 ;lowpass filter (A)
21     ;enter 0 to skip lp-filter

RR x23 ;hipass filter (A)
411    ;enter 0 to skip hp-filter

; ~~~~~ start ~~~~~
MD
set mp
(0)

;--- make a list of particles ---
x99=0
IQ FI x99
<list>
IF(x99.eq.1)GOTO LB90

FI x26
<pcldir>/<stack>@
(26) ;maxnum

@listfiles
<pcldir>/<stack>@******
<list>
(x26)

LB90 ;skip to here if list exists

;--- center and interpolate ---
x99=0
IQ FI x99
<pcldir>/c<stack>av
IF(x99.eq.1)GOTO LB91

AS R
<pcldir>/<stack>@******
<list>
A
<pcldir>/<stack>av
<pcldir>/<stack>va

;center and crop stack
@centerbymirrors(x31,x32)
<pcldir>/<stack>av
_14
DE
_14

x30=0 ;rotation
x31=int(x31) ;x-shift
x32=int(x32) ;y-shift
x33=1 ;key
;      rt ,xsh,ysh
SD x33,x30,x31,x32
<pcldir>/centerdoc
SD E
<pcldir>/centerdoc

FS
<pcldir>/<stack>av
FI x33
<pcldir>/<stack>av
(12)

UD N x34
<list>
UD E

x39=x31*x32
IF(x39.eq.0)THEN ;no centering needed
  VM
  echo No particle centering required.
  CP
  <pcldir>/<stack>@
  _14@
  x34
ELSE
  MS
  _14@
  x33,x33,(1)
  x34 ;number of images
  ;x34 ;highest image (only for indexed - MS I)
  
  @rtmr
  <pcldir>/centerdoc
  <list>
  <pcldir>/<stack>@******
  _14@******
ENDIF

;write _14 to disk temporarily
CP
_14@
<pcldir>/c<stack>@

DE
_14

; --- interpolate & crop ---
IF(x25.le.0)x25=x24 ;No interpolation: newApix=oldApix
IF(x20.le.2)x20=int(x33*x24/x25) ;calculate newBoxSize if not given
x37=abs(x25-x24)+abs(x33-x20) ;are newApix and newBox really new
IF(x37.ne.0)THEN ;if boxSize or Apix change
  MS
  _15@
  x20,x20,(1)
  x34
  
  @interpol(x24,x25,x20)  ;(inApix,outApix,outSize)
  <list>
  <pcldir>/c<stack>@****** ;_14@******
  _15@******
ELSE
  CP
  <pcldir>/c<stack>@ ;_14@
  _15@
  x34
ENDIF

DE
<pcldir>/c<stack> ;_14

AS R
_15@******
<list>
A
<pcldir>/c<stack>av
<pcldir>/c<stack>va

LB91 ;skip center/crop

; --- normalize ----
x99=0
IQ FI x99
<pcldir>/n<stack>av
IF(x99.eq.1)GOTO LB92

IF(x41.eq.0)THEN ;skip normalize
  VM
  echo "***** StDev = 0, skipping particle normalization *****"
  
  CP
  _15@
  <pcldir>/n<stack>@
  x34
ELSE
  MO ;make model noise distribution
  _11
  (1000,1000,1)
  R ;random
  Y ;gaussian
  (x40,x41) ;mean,stdev

  x21=int(x20*2.5/6) ;normalize radius = halfway between particle (2/6) and box (3/6)

  ;normalize particles
  @pclnorm(x21)
  <list>
  _15@******
  _11
  <pcldir>/n<stack>@******

  DE
  _11
ENDIF
DE
_15
  
AS R
<pcldir>/n<stack>@******
<list>
A
<pcldir>/n<stack>av
<pcldir>/n<stack>va

LB92 ;end normalize

x99=0
IQ FI x99
<pcldir>/fn<stack>av
IF(x99.eq.1)GOTO LB93 ;skip filtration

;butterworth filter particles
@filter(x22,x23,x25) ;loPass,hiPass,newApix
<list>
<pcldir>/n<stack>@******
<pcldir>/fn<stack>@******

AS R
<pcldir>/fn<stack>@******
<list>
A
<pcldir>/fn<stack>av
<pcldir>/fn<stack>va

LB93 ;end filter

; --- mask corners of particles ---
FS
<pcldir>/fn<stack>av
FI x20
<pcldir>/fn<stack>av
(12)

x27=x20*2     ;make box 2x larger for softening mask
x28=x20+0.5   ;center of box
x29=x20*3/5   ;maskradius - just cuts corners (if box=100;radius is 60)

PT ;make circle
_11
x27,x27 ;imagesize
C       ;circle
x28,x28 ;origin
x29     ;radius
N

x29=x20/10 ;filterwidth
BC ;soften circle edges
_11
_12
L       ;lowpass
x29,x29 ;width x,y
(1)     ;weight

x29=x20/2 ;topleft
WI ;crop
_12
_13
x20,x20 ;boxsize
x29,x29 ;topleft

FS
_13
FI x27,x28
_13
(7,8) ;max,min

x29=(1/(x27-x28)) ;slope
x30=0-(1/(x27-x28))*x28 ;intercept

AR ;rescale after filter
_13
<pcldir>/softcornermask
P1*x29+x30

DE
_11
DE
_12
DE
_13

@maskshift
<list>
<pcldir>/fn<stack>@******
<pcldir>/softcornermask
<pcldir>/mfn<stack>@******
<pcldir>/maskshiftdoc

AS R
<pcldir>/mfn<stack>@******
<list>
A
<pcldir>/mfn<stack>av
<pcldir>/mfn<stack>va

VM
echo "____ Check <pcldir>/mfn<stack> average and variance to be sure preprocessing went OK. ____"

@findradius(x90)
<pcldir>/mfn<stack>av

@findradius(x91)
<pcldir>/mfn<stack>va

x91=int((x90+x91)/2)
VM
echo ____ You might use a radius of {%F7.1%x91} for your particle alignments. ____

@makemask(x91)
<pcldir>/mfn<stack>av
<pcldir>/mfn<stack>va
<pcldir>/circlemask

VM
echo ____ You might consider using <pcldir>/circlemask for classification. _____

EN D
