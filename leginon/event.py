#
# COPYRIGHT:
#       The Leginon software is Copyright 2003
#       The Scripps Research Institute, La Jolla, CA
#       For terms of the license agreement
#       see  http://ami.scripps.edu/software/leginon-license
#

# defines the Event and EventHandler classes

import data

def eventClasses():
	"""
	returns a dict:   {name: class_object, ...}
	that contains all the Event subclasses defined in this module
	"""
	eventclasses = {}
	all_attrs = globals()
	for name,value in all_attrs.items():
		if type(value) == type:
			if issubclass(value, Event):
				eventclasses[name] = value
	return eventclasses

class Event(data.Data):
	def typemap(cls):
		t = data.Data.typemap()
		t += [('node', str), ('confirm', tuple), ('destination', str)]
		return t
	typemap = classmethod(typemap)

class EventLog(data.Data):
	def typemap(cls):
		t = data.Data.typemap()
		t += [ ('eventclass', str), ('status', str), ]
		return t
	typemap = classmethod(typemap)


## Standard Event Types:
##
##	Event
##		NotificationEvent
##			NodeAvailableEvent
##				LauncherAvailableEvent
##			NodeUnavailableEvent
##			PublishEvent
##			UnpublishEvent
##			ConfirmationEvent
##		ControlEvent
##			StartEvent
##			Stopvent
##			KillEvent
##			PauseEvent
##			ResumeEvent
##			NumericControlEvent
##			CreateNodeEvent
##			LockEvent
##			UnlockEvent

### generated by a node to notify manager that node is ready
class NotificationEvent(Event):
	'Event sent for notification'
	pass

## I'm definietely not sure about this one
class NodeAvailableEvent(NotificationEvent):
	'Event sent by a node to the manager to indicate that it is accessible'
	def typemap(cls):
		t = NotificationEvent.typemap()
		t += [('location', dict), ('nodeclass', str)]
		return t
	typemap = classmethod(typemap)

class NodeUnavailableEvent(NotificationEvent):
	'Event sent by a node to the manager to indicate that it is inaccessible'
	pass

class NodeInitializedEvent(NotificationEvent):
	'Event sent by a node to indicate that it is operational'
	pass

class NodeUninitializedEvent(NotificationEvent):
	'Event sent by a node to indicate that it is no longer operational'
	pass

class TargetListDoneEvent(NotificationEvent):
	'Event indicating target list is done'
	def typemap(cls):
		t = NotificationEvent.typemap()
		t += [ ('targetlistid', tuple), ('status', str)]
		return t
	typemap = classmethod(typemap)

class ImageProcessDoneEvent(NotificationEvent):
	'Event indicating target list is done'
	def typemap(cls):
		t = NotificationEvent.typemap()
		t += [ ('imageid', int), ('status', str)]
		return t
	typemap = classmethod(typemap)

class DriftDoneEvent(NotificationEvent):
	'Event indicating that drift has ended'
	def typemap(cls):
		t = NotificationEvent.typemap()
		t += [('status', str)]
		return t
	typemap = classmethod(typemap)

class GridInsertedEvent(NotificationEvent):
	'Event indicating a grid has been inserted'
	def typemap(cls):
		t = NotificationEvent.typemap()
		t += [('grid', data.GridData)]
		return t
	typemap = classmethod(typemap)

class GridExtractedEvent(NotificationEvent):
	'Event indicating a grid has been extracted'
	def typemap(cls):
		t = NotificationEvent.typemap()
		t += [('grid', data.GridData)]
		return t
	typemap = classmethod(typemap)

class MosaicDoneEvent(NotificationEvent):
	'Event indicating mosaic is done'
	pass

class PublishEvent(NotificationEvent):
	'Event indicating data was published'
	def typemap(cls):
		if not hasattr(cls, 'dataclass'):
			raise RuntimeError('need to define "dataclass" for publish event')
		t = NotificationEvent.typemap()
		t += [ ('data', cls.dataclass), ]
		return t
	typemap = classmethod(typemap)

class ConfirmationEvent(NotificationEvent):
	'Event sent to confirm event processing'
	def typemap(cls):
		t = NotificationEvent.typemap()
		t += [ ('eventid', tuple), ]
		t += [ ('status', str), ]
		return t
	typemap = classmethod(typemap)

class ImageTargetShiftPublishEvent(PublishEvent):
	dataclass = data.ImageTargetShiftData

class NeedTargetShiftEvent(NotificationEvent):
	'''notify DriftManager that I want another ImageTargetShift'''
	def typemap(cls):
		t = NotificationEvent.typemap()
		t += [ ('imageid', tuple), ]
		return t
	typemap = classmethod(typemap)

## this is a PublishEvent because we want to publish the EM state
## that was used to detect the drift, so that we can continue to monitor
## drift at this state.
class DriftDetectedEvent(PublishEvent):
	dataclass = data.DriftDetectedData
	
class NodeClassesPublishEvent(PublishEvent):
	'Event indicating launcher published new list of node classes'
	dataclass = data.NodeClassesData

class ImagePublishEvent(PublishEvent):
	'Event indicating image was published'
	dataclass = data.ImageData

class CameraImagePublishEvent(ImagePublishEvent):
	'Event indicating camera image was published'
	dataclass = data.CameraImageData

class CorrectedCameraImagePublishEvent(CameraImagePublishEvent):
	'Event indicating camera image was published'
	dataclass = data.CorrectedCameraImageData

class PresetImagePublishEvent(CameraImagePublishEvent):
	'Event indicating preset camera image was published'
	dataclass = data.PresetImageData

class AcquisitionImagePublishEvent(PresetImagePublishEvent):
	dataclass = data.AcquisitionImageData

class FilmPublishEvent(AcquisitionImagePublishEvent):
	dataclass = data.FilmData

class CorrectorImagePublishEvent(CameraImagePublishEvent):
	dataclass = data.CorrectorImageData

class MosaicPublishEvent(PublishEvent):
	'Event indicating mosaic image was published'
	dataclass = data.MosaicData

class DarkImagePublishEvent(CorrectorImagePublishEvent):
	dataclass = data.DarkImageData

class BrightImagePublishEvent(CorrectorImagePublishEvent):
	dataclass = data.BrightImageData

class NormImagePublishEvent(CorrectorImagePublishEvent):
	dataclass = data.NormImageData

class ImageTargetListPublishEvent(PublishEvent):
	dataclass = data.ImageTargetListData

class ImageListPublishEvent(PublishEvent):
	dataclass = data.ImageListData

class AcquisitionImageListPublishEvent(ImageListPublishEvent):
	dataclass = data.AcquisitionImageListData

class ScopeEMPublishEvent(PublishEvent):
	dataclass = data.ScopeEMData

class CameraEMPublishEvent(PublishEvent):
	dataclass = data.CameraEMData

class CameraImageEMPublishEvent(PublishEvent):
	dataclass = data.CameraEMData

class ControlEvent(Event):
	'Event that passes a value with it'
	pass

class KillEvent(ControlEvent):
	'Event that signals a kill'
	pass

class SetManagerEvent(ControlEvent):
	def typemap(cls):
		t = ControlEvent.typemap()
		t += [('location', dict),
					('session', data.SessionData)]
		return t
	typemap = classmethod(typemap)

class CreateNodeEvent(ControlEvent):
	'ControlEvent sent to a NodeLauncher specifying a node to launch'
	def typemap(cls):
		t = ControlEvent.typemap()
		t += [
			('targetclass', str),
			('session', data.SessionData),
			('manager location', dict)
		]
		return t
	typemap = classmethod(typemap)

class LockEvent(ControlEvent):
	'Event that signals a lock'
	pass
	
class UnlockEvent(ControlEvent):
	'Event that signals an unlock'
	pass

class InsertGridEvent(ControlEvent):
	'Event that signals a grid to be inserted'
	pass

class ExtractGridEvent(ControlEvent):
	'Event that signals a grid to be extracted'
	pass

class MakeTargetListEvent(ControlEvent):
	'Event telling target maker to make a target list'
	def typemap(cls):
		t = NotificationEvent.typemap()
		t += [('grid', data.GridData)]
		return t
	typemap = classmethod(typemap)

class EmailEvent(Event):
	'Event to send email'
	def typemap(cls):
		t = Event.typemap()
		t += [('subject', str)]
		t += [('text', str)]
		t += [('image string', str)]
		return t
	typemap = classmethod(typemap)

class ChangePresetEvent(Event):
	def typemap(cls):
		t = Event.typemap()
		t += [ ('name', str), ('emtarget', data.EMTargetData)]
		return t
	typemap = classmethod(typemap)

class PresetChangedEvent(Event):
	def typemap(cls):
		t = Event.typemap()
		t += [ ('name', str), ]
		t += [ ('preset', data.PresetData), ]
		return t
	typemap = classmethod(typemap)

class SetEMEvent(PublishEvent):
	pass

class SetScopeEvent(SetEMEvent):
	dataclass = data.ScopeEMData

class SetCameraEvent(SetEMEvent):
	dataclass = data.CameraEMData

class DeviceLockEvent(ControlEvent):
	pass

class DeviceUnlockEvent(ControlEvent):
	pass

class DeviceGetPublishEvent(PublishEvent):
	dataclass = data.DeviceGetData

class DevicePublishEvent(PublishEvent):
	dataclass = data.DeviceData
	def typemap(cls):
		t = PublishEvent.typemap()
		t += [('get data ID', tuple)]
		return t
	typemap = classmethod(typemap)

'''
class DeviceGetEvent(Event):
	def typemap(cls):
		t = Event.typemap()
		t += [('data ID', tuple),]
		return t
	typemap = classmethod(typemap)

class DeviceSetEvent(Event):
	def typemap(cls):
		t = Event.typemap()
		t += [('data ID', tuple),]
		return t
	typemap = classmethod(typemap)
'''

class DeviceConfirmationEvent(ConfirmationEvent):
	def typemap(cls):
		t = ConfirmationEvent.typemap()
		t += [('data ID', tuple),]
		return t
	typemap = classmethod(typemap)

# generate the mapping of data class to publish event class
publish_events = {}
event_classes = eventClasses()
for eventclass in event_classes.values():
	if issubclass(eventclass, PublishEvent):
		if hasattr(eventclass, 'dataclass'):
			publish_events[eventclass.dataclass] = eventclass

# event related exceptions

class InvalidEventError(TypeError):
	pass


# generate the mapping of data class to publish event class
publish_events = {}
event_classes = eventClasses()
for eventclass in event_classes.values():
	if issubclass(eventclass, PublishEvent):
		if hasattr(eventclass, 'dataclass'):
			if eventclass.dataclass in publish_events:
				## for now we will just avoid a conflict
				publish_events[eventclass.dataclass] = None
			else:
				publish_events[eventclass.dataclass] = eventclass

# event related exceptions

class InvalidEventError(TypeError):
	pass

